<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trivial Endgames</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/assets/chessboard.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/assets/extensions/arrows/arrows.css">

  <style>
    :root {
      --bg: #0b0f17;
      --panel: #111828;
      --panel2: #0f1624;
      --text: #e7eefc;
      --muted: #a9b6cf;
      --border: rgba(231, 238, 252, 0.12);
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --btn: #1c2a44;
      --btnHover: #243659;
      
      /* Spec Palette */
      --color-analysis: #6FB4FF;
      --color-win: #1F6F4A;
      --color-win-best: #2ecc71;
      --color-draw: #95a5a6;
      --color-loss: #e74c3c;
      --color-neutral-icon: rgba(255,255,255,0.55);

      --pagePad: 24px;
      --cardPad: 16px;
      --gap: 18px;
      --boardSize: min(600px, 65vh);
    }

    @media (max-width: 900px) {
      :root { --gap: 14px; --boardSize: min(580px, 60vh); }
      body { place-items: start center; }
    }

    @media (max-width: 600px) {
      :root {
        --pagePad: 10px;
        --cardPad: 10px;
        --gap: 10px;
        --boardSize: min(96vw, 46svh, 500px);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 50% 0%, #162445 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100svh;
      padding: var(--pagePad);
      display: grid;
      place-items: center;
    }

    .app {
      width: min(1000px, 100%);
      display: grid;
      gap: var(--gap);
    }

    header {
      display: flex;
      gap: 12px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: var(--gap);
      align-items: start;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .boardCard {
      padding: 0; /* Removed padding for full-bleed board */
      display: grid;
      place-items: center;
      border: none; /* Optional: remove card border if desired, but padding=0 usually fixes the 'frame' look */
      background: transparent; /* Remove card background so only board shows */
      box-shadow: none;
    }

    /* Force hide cm-chessboard border if JS setting fails */
    .cm-chessboard .border { 
        display: none !important; 
        stroke: none !important;
    }

    /* Promotion Dialog visibility fix */
    .cm-chessboard-promotion-dialog {
        background: white !important;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    
    /* Target SVG background rect if present */
    .promotion-dialog-group rect, 
    .cm-chessboard-content .promotion-dialog-group rect {
        fill: white !important;
        stroke: #999 !important;
    }
    
    /* Ensure context menu style dialogs are also white */
    div[class*="promotion-dialog"] {
        background-color: white !important;
    }

    .cm-chessboard-promotion-dialog .promotion-piece {
        cursor: pointer;
    }

    .boardSizer {
      width: min(100%, var(--boardSize));
      height: min(100%, var(--boardSize));
      overflow: visible;
    }

    #board {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }

    .sideCard {
      padding: var(--cardPad);
      display: grid;
      gap: 10px;
    }

    .status {
      padding: 12px 14px;
      border-radius: 14px;
      border: none; /* Removed border */
      background: transparent; /* Removed background */
      color: #e7eefc; /* Matched to title color */
      font-size: 14px;
      line-height: 1.35;
      white-space: pre-wrap;
      text-align: center;
      min-height: 3em;
      display: flex; align-items: center; justify-content: center;
    }
    .status.ok   { border-color: rgba(46, 204, 113, 0.35); color: rgba(46, 204, 113, 0.95); }
    .status.bad  { border-color: rgba(255, 92, 92, 0.35); color: rgba(255, 92, 92, 0.95); }
    .status.warn { border-color: rgba(255, 204, 102, 0.35); color: rgba(255, 204, 102, 0.95); }

    .btnRow {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .btnRow2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button, a.linkBtn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.3); /* Subtle border */
      background: transparent; /* No solid background */
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 750;
      letter-spacing: 0.2px;
      transition: transform 0.04s ease, background 0.15s ease, opacity 0.15s ease, border-color 0.15s ease;
      text-align: center;
      text-decoration: none;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      min-height: 44px;
      font-size: 0.95rem;
    }
    button:hover, a.linkBtn:hover { 
        background: rgba(255,255,255,0.08); 
        border-color: rgba(255,255,255,0.5);
    }
    button:active, a.linkBtn:active { transform: translateY(1px); }
    button:disabled, a.linkBtn[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .hidden { display: none !important; }

    #btnNew {
        font-weight: normal;
        background: #3b82f6 !important;
        color: #ffffff !important;
        border: none !important;
    }

    button:hover#btnNew {
        background: #2563eb !important; /* Slightly darker on hover */
    }

    .btn-win { background: var(--color-win) !important; color: #e7eefc !important; }
    .btn-draw { background: var(--color-draw) !important; color: #e7eefc !important; }
    .btn-loss { background: var(--color-loss) !important; color: #e7eefc !important; }
    .btn-win:hover, .btn-draw:hover, .btn-loss:hover { filter: brightness(1.1); }

    .marker-source {
        fill: rgba(20, 85, 30, 0.5) !important; /* Lichess-style greenish background */
        stroke: none;
        pointer-events: none;
    }

    .marker-dest {
        fill: rgba(20, 85, 30, 0.5) !important; /* Lichess-style green dots */
        stroke: none;
        pointer-events: none;
    }

    /* Analysis Mode Markers (Flashy) */
    .marker-god-win { fill: var(--color-win-best); opacity: 0.6; pointer-events: none; }
    .marker-god-win-best { fill: var(--color-win-best); opacity: 0.8; pointer-events: none; }
    .marker-god-draw { fill: var(--color-draw); opacity: 0.6; pointer-events: none; }
    .marker-god-loss { fill: var(--color-loss); opacity: 0.6; pointer-events: none; }

    /* Ensure markers are on top of pieces */
    /* Marker overlay (above pieces) */
    #markerOverlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 60;
      overflow: visible;
    }

    #markerOverlay .marker-dtm-text {
      pointer-events: none;
      user-select: none;
    }

    #board svg .marker-dot {
        z-index: 10;
        pointer-events: none;
    }
    
    #board svg .marker-square {
        z-index: 1;
        pointer-events: none;
    }

    /* Link lines to custom markers defined in HTML */
    .arrow-win line, .arrow-win path { 
        stroke: var(--color-win) !important; 
        stroke-width: 6px !important;
        marker-end: url(#arrowHeadWin) !important;
        fill: none !important;
    }
    
    .arrow-win-best line, .arrow-win-best path { 
        stroke: var(--color-win-best) !important; 
        stroke-width: 6px !important;
        marker-end: url(#arrowHeadWinBest) !important;
        fill: none !important;
    }

    .arrow-draw line, .arrow-draw path { 
        stroke: var(--color-draw) !important; 
        stroke-width: 6px !important;
        marker-end: url(#arrowHeadDraw) !important;
        fill: none !important;
    }

    .arrow-loss line, .arrow-loss path { 
        stroke: var(--color-loss) !important; 
        stroke-width: 6px !important;
        marker-end: url(#arrowHeadLoss) !important;
        fill: none !important;
    }

    /* Common visual finish */
    .arrow-win, .arrow-draw, .arrow-loss, .arrow-win-best {
        opacity: 0.9;
        filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
    }
    
    /* Ensure the lines have round caps */
    .arrow-win line, .arrow-draw line, .arrow-loss line, .arrow-win-best line {
        stroke-linecap: round;
    }

    /* Remove old marker styling attempts */

    /* Analysis Mode Toggle styling */
    #godModeBtn {
        /* Matches standard button style (linkBtn) */
        color: #ffffff; /* Always use white for the icon */
        font-size: 1.2rem;
    }

    /* Fix mobile vertical jump by overriding body alignment at the end of cascade */
    @media (max-width: 900px) {
      body { place-items: start center; }
    }

  </style>
</head>

<body>
  <!-- Custom SVG Markers for Arrows -->
  <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" aria-hidden="true">
    <defs>
      <marker id="arrowHeadWin" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-win)" />
      </marker>
      <marker id="arrowHeadWinBest" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-win-best)" />
      </marker>
      <marker id="arrowHeadDraw" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-draw)" />
      </marker>
      <marker id="arrowHeadLoss" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-loss)" />
      </marker>
    </defs>
  </svg>

  <div class="app">
    <header>
      <h1>Trivial Endgames</h1>
    </header>

    <section class="layout">
      <div class="card boardCard">
        <div class="boardSizer">
          <div id="board" aria-label="Chessboard"></div>
        </div>
      </div>

      <div class="sideCard">
        
        <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px; padding: 4px 0;">
             <!-- Styled Dropdown Container -->
             <div style="position:relative; display:inline-flex; align-items:center; cursor:pointer;">
                 <select id="endgameSelect" style="appearance:none; -webkit-appearance:none; background:transparent; border:none; color:#FFFFFF; font-size:1.4rem; cursor:pointer; padding-right:20px; outline:none; font-family:inherit;">
                     <option value="KP_K" style="background:var(--bg);">♚♟ vs ♔</option>
                     <option value="K_KP" style="background:var(--bg);">♚ vs ♔♙</option>
                     <option value="KP_KR" style="background:var(--bg);">♚♟ vs ♔♖</option>
                     <option value="KR_KP" style="background:var(--bg);">♚♜ vs ♔♙</option>
                     <option value="KRP_KR" style="background:var(--bg);">♚♜♟ vs ♔♖</option>
                     <option value="KR_KRP" style="background:var(--bg);">♚♜ vs ♔♖♙</option>
                     <option value="KBP_KB" style="background:var(--bg);">♚♝♟ vs ♔♗</option>
                 </select>
                 <!-- Chevron Icon -->
                 <span style="position:absolute; right:0; pointer-events:none; color:#FFFFFF; font-size:0.8rem; margin-top:2px;">▾</span>
             </div>

             <div class="streak-card" style="white-space:nowrap; padding: 10px 0; border:none; background:transparent; font-size:14px; display:flex; align-items:center; justify-content:center;">
                Streak: <strong id="streak" style="margin-left:5px; font-size: 1.1rem;">0</strong>
             </div>
        </div>

        <div style="display:flex; gap:10px; align-items:stretch;">
            <div id="status" class="status" style="flex-grow:1;">Initializing...</div>
            
            <button id="btnUndo" class="hidden" style="width: 50px; padding:0; font-size:1.5rem; border-radius:14px;" title="Undo last move">↺</button>
        </div>

        <div class="btnRow" id="guessControls" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; align-items:center;">
          <button class="btn-win" id="btnWin">Win</button>
          <button class="btn-draw" id="btnDraw">Draw</button>
          <button class="btn-loss" id="btnLoss">Loss</button>
        </div>

        <div class="btnRow2" style="display:flex; gap:10px; align-items:stretch; width:100%;">
          <button id="btnNew" style="flex:2;" title="New Position">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
              <path d="M3 21v-5h5" />
              <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
              <path d="M21 3v5h-5" />
              <rect x="9" y="9" width="6" height="6" rx="0.5" />
              <path d="M12 9v6" />
              <path d="M9 12h6" />
            </svg>
          </button>
          
          <button id="godModeBtn" class="linkBtn" style="flex:1;" title="Analysis Mode">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="8" />
              <line x1="21" y1="21" x2="16.65" y2="16.65" />
              <rect x="8" y="8" width="6" height="6" rx="1" />
              <line x1="8" y1="11" x2="14" y2="11" />
              <line x1="11" y1="8" x2="11" y2="14" />
            </svg>
          </button>
          
          <a id="analyzeLink" class="linkBtn" href="#" target="_blank" rel="noopener noreferrer" aria-disabled="true" title="Analyze on Lichess" style="flex:1;">
            <!-- Local Lichess Logo -->
            <img src="Lichess-White-Logo-Online-Chess-49.png" alt="Lichess" height="24" style="object-fit: contain;">
          </a>
        </div>
      </div>
    </section>
  </div>

  <script type="module">
    // Debug helper
    window.onerror = function(msg, url, line, col, error) {
       document.getElementById("status").textContent = "JS Error: " + msg;
       document.getElementById("status").className = "status bad";
    };

    import { Chessboard, COLOR, BORDER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/Chessboard.js";
    import { Arrows, ARROW_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/extensions/arrows/Arrows.js";
    import { PromotionDialog } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/extensions/promotion-dialog/PromotionDialog.js";
    import { Chess } from "https://cdn.jsdelivr.net/npm/chess.js@1.0.0-beta.7/+esm";



    // Overlay markers rendered above pieces (independent from cm-chessboard Markers extension)
    class OverlayMarkers {
        constructor(chessboard, containerEl) {
            this.chessboard = chessboard;
            this.containerEl = containerEl;
            this.keyToNodes = new Map(); // key -> {shape, text}

            // Ensure the container is a positioning context
            try {
                const cs = window.getComputedStyle(this.containerEl);
                if (cs.position === 'static') this.containerEl.style.position = 'relative';
            } catch (e) {
                // No-op
            }

            // Create overlay SVG
            this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.svg.setAttribute("id", "markerOverlay");
            this.svg.setAttribute("aria-hidden", "true");
            this.svg.style.position = "absolute";
            this.svg.style.inset = "0";
            this.svg.style.width = "100%";
            this.svg.style.height = "100%";
            this.svg.style.pointerEvents = "none";
            this.svg.style.zIndex = "60";
            this.svg.style.overflow = "visible";

            this.gMarkers = document.createElementNS("http://www.w3.org/2000/svg", "g");
            this.gText = document.createElementNS("http://www.w3.org/2000/svg", "g");
            this.svg.appendChild(this.gMarkers);
            this.svg.appendChild(this.gText);
            this.containerEl.appendChild(this.svg);

            // Keep overlay synced with the main board SVG viewBox
            this._mo = new MutationObserver(() => this.sync());
            this._startObservers();
            window.addEventListener('resize', () => this.sync(), { passive: true });

            // Initial sync (some browsers create the internal SVG asynchronously)
            this.sync();
            requestAnimationFrame(() => this.sync());
        }

        _startObservers() {
            const tryAttach = () => {
                const mainSvg = this.chessboard?.view?.svg;
                if (mainSvg) {
                    this._mo.observe(mainSvg, { attributes: true, attributeFilter: ['viewBox', 'width', 'height', 'preserveAspectRatio'] });
                    return true;
                }
                return false;
            };

            if (!tryAttach()) {
                // Retry a few frames in case the internal SVG isn't ready yet
                let tries = 0;
                const tick = () => {
                    tries += 1;
                    if (tryAttach() || tries > 20) return;
                    requestAnimationFrame(tick);
                };
                requestAnimationFrame(tick);
            }
        }

        sync() {
            const mainSvg = this.chessboard?.view?.svg;
            if (!mainSvg) return;

            const vb = mainSvg.getAttribute('viewBox');
            if (vb) this.svg.setAttribute('viewBox', vb);

            const par = mainSvg.getAttribute('preserveAspectRatio');
            if (par) this.svg.setAttribute('preserveAspectRatio', par);
        }

        clear() {
            this.keyToNodes.clear();
            while (this.gMarkers.firstChild) this.gMarkers.removeChild(this.gMarkers.firstChild);
            while (this.gText.firstChild) this.gText.removeChild(this.gText.firstChild);
        }

        add(markerDef, square) {
            if (!markerDef || !square) return;
            this.sync();

            const view = this.chessboard?.view;
            if (!view || typeof view.squareToPoint !== 'function') return;

            const point = view.squareToPoint(square);
            const w = view.squareWidth;
            const h = view.squareHeight;
            const minDim = Math.min(w, h);

            const key = `${markerDef.class || 'marker'}:${square}`;

            // Replace if already present
            const existing = this.keyToNodes.get(key);
            if (existing) {
                if (existing.shape && existing.shape.parentNode) existing.shape.parentNode.removeChild(existing.shape);
                if (existing.text && existing.text.parentNode) existing.text.parentNode.removeChild(existing.text);
                this.keyToNodes.delete(key);
            }

            const slice = String(markerDef.slice || 'markerDot');
            let shape = null;
            if (slice.toLowerCase().includes('square')) {
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', point.x);
                rect.setAttribute('y', point.y);
                rect.setAttribute('width', w);
                rect.setAttribute('height', h);
                rect.classList.add('marker-square');
                if (markerDef.class) rect.classList.add(markerDef.class);
                rect.style.pointerEvents = 'none';
                shape = rect;
            } else {
                const cx = point.x + w / 2;
                const cy = point.y + h / 2;
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', minDim * 0.18);
                circle.classList.add('marker-dot');
                if (markerDef.class) circle.classList.add(markerDef.class);
                circle.style.pointerEvents = 'none';
                shape = circle;
            }

            this.gMarkers.appendChild(shape);

            // DTM label (only when dtm != 0)
            let textEl = null;
            const dtm = markerDef.dtm;
            if (Number.isFinite(dtm) && dtm !== 0) {
                const cx = point.x + w / 2;
                const cy = point.y + h / 2;

                textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textEl.setAttribute('x', cx);
                textEl.setAttribute('y', cy);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('dominant-baseline', 'central');
                textEl.setAttribute('class', 'marker-dtm-text');
                textEl.textContent = String(dtm);

                textEl.style.pointerEvents = 'none';
                textEl.style.fontFamily = 'ui-sans-serif, system-ui, sans-serif';
                textEl.style.fontWeight = '900';
                textEl.style.fontSize = (minDim * 0.30) + 'px';

                // High contrast, readable on any marker color
                textEl.style.fill = '#ffffff';
                textEl.style.stroke = '#000000';
                textEl.style.strokeWidth = (minDim * 0.07) + 'px';
                textEl.style.paintOrder = 'stroke';

                this.gText.appendChild(textEl);
            }

            this.keyToNodes.set(key, { shape, text: textEl });
        }
    }

    const MARKER_SOURCE = { class: "marker-source", slice: "markerSquare" };
    const MARKER_DEST = { class: "marker-dest", slice: "markerDot" };
    
    const MARKER_GOD_WIN = { class: "marker-god-win", slice: "markerDot" };
    const MARKER_GOD_WIN_BEST = { class: "marker-god-win-best", slice: "markerDot" };
    const MARKER_GOD_DRAW = { class: "marker-god-draw", slice: "markerDot" };
    const MARKER_GOD_LOSS = { class: "marker-god-loss", slice: "markerDot" };
    
    const ARROW_WIN = { ...ARROW_TYPE.default, class: "arrow-win" };
    const ARROW_WIN_BEST = { ...ARROW_TYPE.default, class: "arrow-win-best" };
    const ARROW_DRAW = { ...ARROW_TYPE.default, class: "arrow-draw" };
    const ARROW_LOSS = { ...ARROW_TYPE.default, class: "arrow-loss" };

    const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-";
    const PIECE_ORDER = "KQRBNP";

    console.log("Imports loaded");
    document.getElementById("status").textContent = "Imports loaded...";
    
    const TABLEBASE_URL = "https://tablebase.lichess.ovh/standard?fen=";

    // --- DOM Elements ---
    const el = {
      status: document.getElementById("status"),
      streak: document.getElementById("streak"),
      btnWin: document.getElementById("btnWin"),
      btnDraw: document.getElementById("btnDraw"),
      btnLoss: document.getElementById("btnLoss"),
      btnNew: document.getElementById("btnNew"),
      analyze: document.getElementById("analyzeLink"),
      guessControls: document.getElementById("guessControls"),
      btnUndo: document.getElementById("btnUndo"),
      godModeBtn: document.getElementById("godModeBtn"),
    };

    // --- State ---
    let chess = new Chess();
    let board = null;
    let currentFen = "";
    let initialFen = "";
    let currentTbData = null;
    let streak = 0;
    let isUserTurn = false;
    let gameActive = false;
    let selectedSquare = null;
    let cachedPositions = null;
    let cachedFilename = null;
    let godMode = false;
    let analysisMode = false;
    let streakInvalidated = false;

    function isReallyGameOver() {
        return chess.isCheckmate() || (chess.isDraw() && !chess.isThreefoldRepetition());
    }

    // --- Init Board ---
    board = new Chessboard(document.getElementById("board"), {
      assetsUrl: "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/assets/",
      position: "8/8/8/8/8/8/8/8", // "empty" keyword crashes, use explicit FEN
      orientation: COLOR.white,
      style: {
        pieces: { file: "pieces/standard.svg" },
        borderType: BORDER_TYPE.none
      },
      extensions: [{ class: Arrows }, { class: PromotionDialog }]
    });

    const overlayMarkers = new OverlayMarkers(board, document.getElementById("board"));

    board.enableMoveInput((event) => {
        if (!isUserTurn || !gameActive) return false;

        switch (event.type) {
            case "moveInputStarted":
                const p = chess.get(event.square);
                // In Analysis Mode, allow picking up any piece relative to turn
                const isTurnColor = p && p.color === chess.turn();
                const isOurPiece = p && p.color === 'w';
                
                if (godMode || analysisMode ? isTurnColor : isOurPiece) {
                    if (selectedSquare === event.square) {
                        selectSquare(null);
                        return false; // Stop interaction on deselect
                    } else {
                        selectSquare(event.square);
                        return true;
                    }
                }
                return false;
                
            case "validateMoveInput":
                if (!gameActive && !godMode && !analysisMode) return false;
                try {
                    const temp = new Chess(chess.fen());
                    // Check if move is legal (ignoring promotion for now to check basic validity)
                    // We need to check if promotion is needed
                    const piece = temp.get(event.squareFrom);
                    const isPawn = piece && piece.type === 'p';
                    const targetRank = event.squareTo[1];
                    const isPromo = isPawn && (targetRank === '1' || targetRank === '8');
                    
                    if (isPromo) {
                        // Check if move is valid with 'q' promotion (just to validate geometry)
                        const m = temp.move({ from: event.squareFrom, to: event.squareTo, promotion: 'q' });
                        if (m) {
                            // Show dialog
                            // We return true to allow the piece to snap to the square, 
                            // then we'll handle the actual logic in moveInputFinished?
                            // No, cm-chessboard PromotionDialog usually works by returning true then callback?
                            // Actually, standard pattern is: return true, then use showPromotionDialog.
                            return true; 
                        }
                        return false;
                    }
                    
                    const m = temp.move({ from: event.squareFrom, to: event.squareTo, promotion: 'q' });
                    return !!m;
                } catch (e) { return false; }
                
            case "moveInputFinished":
                // Defer clearing to ensure it happens after any internal event handling
                setTimeout(() => selectSquare(null), 10);
                
                // Check for promotion
                const temp = new Chess(chess.fen());
                const sqFrom = event.squareFrom;
                const sqTo = event.squareTo;
                const piece = temp.get(sqFrom);
                const isPawn = piece && piece.type === 'p';
                const targetRank = sqTo[1];
                const isPromo = isPawn && (targetRank === '1' || targetRank === '8');

                if (event.legalMove) {
                    if (isPromo) {
                        // Show dialog
                        const side = piece.color === 'w' ? COLOR.white : COLOR.black;
                        board.showPromotionDialog(sqTo, side, (result) => {
                            if (result && result.piece) {
                                // Result piece name e.g. "wq", "wr", "bq" -> char 'q', 'r'
                                const promoChar = result.piece[1].toLowerCase();
                                // Execute move logic first (updates chess.js state)
                                handleUserMove(sqFrom, sqTo, promoChar).then(success => {
                                    if (success) {
                                        board.setPosition(chess.fen(), true);
                                    } else {
                                        console.error("Promotion move failed logic.");
                                        board.setPosition(chess.fen(), true);
                                    }
                                });
                            } else {
                                // Cancelled
                                board.setPosition(chess.fen(), true);
                            }
                        });
                        return true; // Let piece drop visually
                    } else {
                        void handleUserMove(sqFrom, sqTo).catch(console.error);
                    }
                }
                return true;
        }
    });

    // --- Event Listeners ---
    el.btnWin.addEventListener("click", () => handleGuess(2)); // Win for White
    el.btnDraw.addEventListener("click", () => handleGuess(0));
    el.btnLoss.addEventListener("click", () => handleGuess(-2));
    
    el.btnNew.addEventListener("click", startNewGame);
    el.btnUndo.addEventListener("click", undoLastMove);
    
    if (el.godModeBtn) {
        el.godModeBtn.addEventListener("click", () => {
            if (godMode) return; // Cannot turn OFF via this button as per request
            
            godMode = true;
            el.godModeBtn.classList.add("active");
            
            // Clear selection/markers on toggle to prevent stale state
            selectSquare(null);
            clearArrows();

            gameActive = true; // Ensure movement is allowed
            analysisMode = false;
            streakInvalidated = true;
            const turnStr = chess.turn() === 'w' ? "White" : "Black";
            setStatus(null, `Analysis Mode On: ${turnStr} to move.`);
            setGuessEnabled(false);
        });
    }

    async function undoLastMove() {
        // Allow undo even if gameActive is false (e.g. after blunder endGame)
        
        // If it's black's turn (user just played and blundered), undo 1 move.
        // If it's white's turn (normal flow), undo 2 moves.
        
        if (chess.turn() === 'b') {
             chess.undo();
        } else {
             chess.undo();
             chess.undo();
        }

        currentFen = chess.fen();
        await board.setPosition(currentFen, true);
        
        // Refresh TB Data
        try {
            currentTbData = await fetchTablebase(currentFen);
            
            // Re-evaluate state
            gameActive = true; // Reactivate game
            isUserTurn = true;
            
            if (godMode || analysisMode) {
                const turnStr = chess.turn() === 'w' ? "White" : "Black";
                if (godMode) setStatus(null, `Analysis Mode On: ${turnStr} to move.`);
                else setStatus(null, `Analysis Mode Off: ${turnStr} to move.`);
            } else if (!el.btnWin.disabled) {
                setStatus(null, "Guess result or Play a move.");
            } else {
                setStatus(null, "");
            }
            
            clearArrows();
            
            if (chess.history().length === 0) {
                 el.btnUndo.classList.add("hidden");
                 el.btnUndo.style.display = 'none';
                 setGuessEnabled(true);
            } else {
                 el.btnUndo.classList.remove("hidden");
                 el.btnUndo.style.display = '';
            }
        } catch(e) { console.error(e); }
    }

    function selectSquare(sq) {
        clearArrows(); // Clear arrows on selection
        overlayMarkers.clear(); // Clear all overlay markers (source, dest, analysis, etc.)
        
        selectedSquare = sq;
        if (selectedSquare) {
            // Add Source Marker
            overlayMarkers.add(MARKER_SOURCE, selectedSquare);
            
            if (godMode && currentTbData && currentTbData.moves) {
                // Analysis Mode: Use TB data to color destinations
                // Filter moves starting from selectedSquare
                const moves = currentTbData.moves.filter(m => m.uci.startsWith(selectedSquare));
                
                // Find best DTM among these winning moves
                let bestDtmForSquare = Infinity;
                const winningMoves = moves.filter(m => categoryToWdl(m.category) === -2);
                winningMoves.forEach(m => {
                    if (m.dtm !== undefined && m.dtm !== null) {
                        const dist = Math.abs(m.dtm);
                        if (dist < bestDtmForSquare) bestDtmForSquare = dist;
                    }
                });

                // Aggregate by destination to handle promotions (pick best outcome)
                // Maps dest -> {wdl, dtm}
                const destMap = new Map();
                
                moves.forEach(m => {
                    const dest = m.uci.slice(2, 4);
                    const wdl = categoryToWdl(m.category); // 2, 0, -2
                    const dtm = m.dtm !== undefined && m.dtm !== null ? Math.abs(m.dtm) : Infinity;
                    
                    if (!destMap.has(dest)) {
                        destMap.set(dest, {wdl, dtm});
                    } else {
                        const current = destMap.get(dest);
                        // Pick best WDL first
                        if (wdl < current.wdl) {
                            destMap.set(dest, {wdl, dtm});
                        } else if (wdl === current.wdl && dtm < current.dtm) {
                            // If same WDL, pick best DTM
                            destMap.set(dest, {wdl, dtm});
                        }
                    }
                });
                
                destMap.forEach((data, dest) => {
                    let markerDef = MARKER_GOD_DRAW;
                    if (data.wdl === -2) {
                        markerDef = (data.dtm <= bestDtmForSquare) ? MARKER_GOD_WIN_BEST : MARKER_GOD_WIN;
                    }
                    else if (data.wdl === 2) markerDef = MARKER_GOD_LOSS;
                    
                    // Clone and inject DTM
                    const marker = { ...markerDef };
                    if (data.dtm !== undefined && data.dtm !== Infinity) {
                        marker.dtm = data.dtm;
                    }
                    
                    overlayMarkers.add(marker, dest);
                });
                
            } else {
                // Standard Mode: Show valid destinations (green dots)
                const moves = chess.moves({ square: selectedSquare, verbose: true });
                moves.forEach(m => {
                    overlayMarkers.add(MARKER_DEST, m.to);
                });
            }
        }
    }

    // --- Persistence ---
    function saveSettings() {
        try {
            const sel = document.getElementById("endgameSelect");
            const val = sel.value;
            localStorage.setItem("endgame-trainer-selection", val);
        } catch(e) { console.warn("Could not save settings", e); }
    }

    function loadSettings() {
        try {
            const val = localStorage.getItem("endgame-trainer-selection");
            if (val) {
                const sel = document.getElementById("endgameSelect");
                if (sel) {
                    sel.value = val;
                }
            }
        } catch(e) { console.warn("Could not load settings", e); }
    }
    
    // Init Persistence
    loadSettings();
    const sel = document.getElementById('endgameSelect');
    if(sel) sel.addEventListener('change', () => {
        saveSettings();
        startNewGame();
    });

    // Start
    startNewGame();


    // --- Core Logic ---

    async function startNewGame() {
        console.log("startNewGame called");
        gameActive = false;
        isUserTurn = false;
        currentTbData = null;
        clearArrows();
        selectSquare(null);
        setGuessEnabled(false);
        if(el.btnUndo) el.btnUndo.classList.add("hidden");
        if(el.godModeBtn) {
            el.godModeBtn.classList.remove("active");
        }
        godMode = false;
        analysisMode = false;
        streakInvalidated = false;
        setStatus("warn", "Generating position...");
        
        try {
            console.log("Generating valid position...");
            const fen = await generateValidPosition();
            console.log("Position generated:", fen);
            
            currentFen = fen;
            initialFen = fen;
            console.log("Loading into Chess.js...");
            try {
                chess.load(fen);
            } catch(loadErr) {
                throw new Error("Chess.load failed on FEN: " + fen + " :: " + loadErr);
            }
            
            console.log("Setting board position...");
            await board.setPosition(fen, true);
            
            // Get initial TB data
            console.log("Fetching TB data...");
            currentTbData = await fetchTablebase(fen);
            console.log("TB Data received", currentTbData);
            
            // Set Objective
            // normalize wdl from category if needed handled in fetchTablebase
            
            updateLinks(initialFen);
            setStatus(null, "Guess result or Play a move.");
            setGuessEnabled(true);
            gameActive = true;
            isUserTurn = true;
            
            // Ensure undo is hidden at start
            if (el.btnUndo) {
                el.btnUndo.classList.add("hidden");
                el.btnUndo.style.display = 'none'; // Force hide
            }

        } catch (e) {
            console.error(e);
            setStatus("bad", "Error: " + e.message);
        }
    }

        async function handleUserMove(from, to, promotion = 'q') {

            console.log("handleUserMove called with:", from, to, promotion);

            clearArrows();

            selectSquare(null);
            
            setGuessEnabled(false);

    

            if (!gameActive) {

                console.warn("handleUserMove aborted: gameActive is false");

                return;

            }

    

            // Move is valid (already checked by cm-chessboard)

            try {

                const moveResult = chess.move({ from, to, promotion });

                if (!moveResult) {

                    console.error("chess.move failed for:", { from, to, promotion });

                    console.log("Current FEN:", chess.fen());

                    console.log("Turn:", chess.turn());

                    return false;

                }

                console.log("chess.move success:", moveResult);

            } catch (err) {

                console.error("chess.move threw error:", err);

                return false;

            }

            

            await handleUserMovePostProcess();

            return true;

        }

    

        async function handleUserMovePostProcess() {

            // Analysis Mode / Sandbox Bypass

            if (godMode || analysisMode) {

                 currentFen = chess.fen();

                 await board.setPosition(currentFen, true); // Ensure board sync

                 

                              // Update Undo visibility

                 

                              if (el.btnUndo && chess.history().length > 0) {

                 

                                  el.btnUndo.classList.remove("hidden");

                 

                                  el.btnUndo.style.display = ''; // Clear inline style

                 

                              }

                 

                 

                 

                              try {

                    currentTbData = await fetchTablebase(currentFen);

                    const turnStr = chess.turn() === 'w' ? "White" : "Black";

                    

                    if (godMode) {

                        setStatus(null, `Analysis Mode On: ${turnStr} to move.`);

                    } else {

                        setStatus(null, `Analysis Mode Off: ${turnStr} to move.`);

                    }

                    

                                    if (isReallyGameOver()) {

                    

                                        handleGameOver();

                    

                                    }

                    

                                 } catch(e) { console.error(e); }

                    

                                 return true;

                    

                            }

    

            isUserTurn = false;

            setStatus("warn", "Thinking...");

    

            // Evaluate Move
            if (!currentTbData || typeof currentTbData.wdl !== 'number') {
                setStatus('bad', 'Internal error: missing tablebase data.');
                endGame(false, 'Internal error: missing tablebase data.');
                return;
            }

            const prevWdl = currentTbData.wdl;

            

            // Fetch new data

            try {

                const newFen = chess.fen();

                console.log("Fetching response for FEN:", newFen);

                const newData = await fetchTablebase(newFen);

                console.log("Response received:", newData);

                

                // Check blunder

                // White moved. Now Black to move.

                // If White was Winning (2), Black should be Losing (-2).

                // If White was Drawing (0), Black should be Drawing (0).

                

                let failed = false;

                let msg = "";

    

                if (prevWdl === 2) { // We were winning

                     if (newData.wdl !== -2) { // Opponent not losing

                         failed = true;

                         // newData.wdl: 2 (Opponent Wins) -> We Lost

                         // newData.wdl: 0 (Draw) -> We Drew

                         const outcome = newData.wdl === 2 ? "Loss" : "Draw";

                         msg = `Blunder! You turned a Win into a ${outcome}.`;

                     }

                } else if (prevWdl === 0) { // Drawing

                     if (newData.wdl === 2) { // Opponent Winning

                         failed = true;

                         msg = "Blunder! You turned a Draw into a Loss.";

                     }

                }

                

                                if (failed) {

                

                                    endGame(false, msg);

                

                                    if (el.btnUndo) {

                

                                        el.btnUndo.classList.remove("hidden");

                

                                        el.btnUndo.style.display = '';

                

                                    }

                

                                    // Revert board to show? No, keep it.

                    return;

                }

    

                if (isReallyGameOver()) {

                    handleGameOver();

                    return;

                }

    

                // Computer Reply (Best Move)

                if (newData.moves && newData.moves.length > 0) {

                    let bestMove = newData.moves[0];

                    console.log("Computer best move (default):", bestMove.uci);

    

                    // Tie-break for Draw: Prefer no capture

                    const bestWdl = categoryToWdl(bestMove.category);

                    if (bestWdl === 0) { // If best outcome is Draw

                        // Filter moves that preserve the Draw

                        const drawMoves = newData.moves.filter(m => categoryToWdl(m.category) === 0);

                        

                        // Look for non-capture among draw moves

                        // Using SAN to detect capture ('x')

                        const nonCapture = drawMoves.find(m => m.san && !m.san.includes('x'));

                        

                        if (nonCapture) {

                            console.log("Switched to non-capture draw move:", nonCapture.uci);

                            bestMove = nonCapture;

                        }

                    }

    

                    const uci = bestMove.uci;

                    const fromC = uci.slice(0, 2);

                    const toC = uci.slice(2, 4);

                    const promoC = uci.length > 4 ? uci[4] : undefined; // e.g. "a7a8q" -> 'q'

                    

                    chess.move({ from: fromC, to: toC, promotion: promoC || 'q' });

                    await board.setPosition(chess.fen(), true);

                    

                    if (isReallyGameOver()) {

                        handleGameOver();

                        return;

                    }

                    

                    // Update state

                    currentFen = chess.fen();

                    currentTbData = await fetchTablebase(currentFen);

                    

                                        

                    

                                        isUserTurn = true;

                    

                                        if (!el.btnWin.disabled) {

                    

                                            setStatus(null, "Guess result or Play a move.");

                    

                                        } else {

                    

                                            setStatus(null, "");

                    

                                        }

                    

                                    if (el.btnUndo && chess.history().length > 0) {

                    

                                        el.btnUndo.classList.remove("hidden");

                    

                                        el.btnUndo.style.display = '';

                    

                                    }

                    

                                    // updateLinks removed

                } else {

                    handleGameOver();

                }

    

            } catch (e) {

                setStatus("bad", "Error: " + e.message);

            }

        }

    function handleGuess(guessWdl) {
        if (!gameActive) return;
        drawOutcomeArrows(currentTbData);
        
        const actualWdl = currentTbData.wdl;
        
        let correct = (guessWdl === actualWdl);
        
        if (correct) {
            if (!streakInvalidated) {
                streak++;
                updateStreak();
            }
            setStatus("ok", `Correct! It is a ${wdlToString(actualWdl)}.`);
        } else {
            streak = 0;
            updateStreak();
            setStatus("bad", `Wrong. It is a ${wdlToString(actualWdl)}.`);
        }
        setGuessEnabled(false);
        // Hide only guess buttons
        // Analysis Mode toggle is always visible now
    }

    async function handleGameOver() {
        let success = false;
        let msg = "";
        
        // Determine Actual Result from User's Perspective (White)
        // 1 = Win, 0 = Draw, -1 = Loss
        let actualResult = 0; 
        
        if (chess.isCheckmate()) {
            if (chess.turn() === 'b') actualResult = 1; // White mated Black
            else actualResult = -1; // Black mated White
        } else {
            actualResult = 0; // Stalemate, Insufficient Material, etc.
        }

        // Determine Theoretical Outcome of the STARTING position
        // We need to fetch or store the initial WDL. 
        // currentTbData tracks current position. 
        // Let's fetch initial position WDL again or store it in startNewGame.
        // For now, let's just fetch it to be safe (or assume initialFen is valid).
        
        let initialWdl = 0;
        try {
            const initData = await fetchTablebase(initialFen);
            // initData.wdl: 2 (Win), 0 (Draw), -2 (Loss)
            if (initData.wdl === 2) initialWdl = 1;
            else if (initData.wdl === -2) initialWdl = -1;
            else initialWdl = 0;
        } catch(e) { console.error("Could not fetch initial WDL", e); }

        // Logic
        if (actualResult === 1) {
            // User Won
            success = true;
            if (initialWdl === 1) msg = "You won a winning position.";
            else if (initialWdl === 0) msg = "You won a drawn position!";
            else msg = "You won a lost position!"; // Analysis Mode or miracle
        } else if (actualResult === -1) {
            // User Lost
            if (initialWdl === 1) {
                success = false;
                msg = "You lost a winning position.";
            } else if (initialWdl === 0) {
                success = false;
                msg = "You lost a drawn position.";
            } else {
                success = true; // Expected loss achieved? usually failure in training but ok here
                msg = "You lost a lost position.";
            }
        } else {
            // Draw
            if (initialWdl === 1) {
                success = false;
                msg = "You drew a winning position.";
            } else if (initialWdl === 0) {
                success = true;
                msg = "You drew a drawn position.";
            } else {
                success = true; // Saved a draw!
                msg = "You drew a lost position!";
            }
        }

        if (success) {
            if (!streakInvalidated) {
                streak++;
                updateStreak();
            }
            setStatus("ok", msg); // Green
        } else {
            // Reset streak on failure
            streak = 0;
            updateStreak();
            setStatus("bad", msg); // Red
        }
        
        endGame(success, msg);
    }

    function endGame(success, msg) {
        gameActive = false;
        isUserTurn = false;
        setStatus(success ? "ok" : "bad", msg);
        setGuessEnabled(false);
        
        if (!success) {
            streak = 0;
            updateStreak();
        }
        // Analysis Mode toggle is always visible now
    }

    // --- Generation & Validation Logic ---

    async function generateValidPosition() {
        // 1. Determine Piece Composition from UI
        let { w, b } = getSelectedPieces();
        
        // Ensure Kings
        if(!w.includes('K')) w.push('K');
        if(!b.includes('K')) b.push('K');

        // 2. Sort Pieces to match file format (K, Q, R, B, N, P)
        const sortOrder = (p) => PIECE_ORDER.indexOf(p);
        w.sort((a, b) => sortOrder(a) - sortOrder(b));
        b.sort((a, b) => sortOrder(a) - sortOrder(b));

        // 3. Construct File Path
        const filename = `${w.join('')}_${b.join('')}.txt`;
        const url = `out/${filename}`; // Relative path

        let text = "";

        // Check Cache
        if (cachedFilename === filename && cachedPositions) {
            console.log(`Using cached positions for: ${filename}`);
            text = cachedPositions;
        } else {
            console.log(`Cache miss. Fetching positions from: ${url}`);
            setStatus("warn", "Fetching position...");

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`No positions found for material: ${w.join('')} vs ${b.join('')}. (File ${filename} missing)`);
                    }
                    throw new Error(`Network error: ${response.status} ${response.statusText}`);
                }

                text = await response.text();
                if (!text) throw new Error("Position file is empty.");
                
                // Update Cache
                cachedPositions = text;
                cachedFilename = filename;

            } catch (e) {
                console.error(e);
                throw new Error(e.message);
            }
        }

        // 4. Calculate Record Details
        const flatList = [
            ...w.map(p => ({ type: p, color: 'w' })),
            ...b.map(p => ({ type: p, color: 'b' }))
        ];
        const recordLength = flatList.length;

        if (text.length % recordLength !== 0) {
            console.warn(`File length (${text.length}) is not a multiple of record length (${recordLength}). Trimming end.`);
        }

        const totalRecords = Math.floor(text.length / recordLength);
        if (totalRecords === 0) throw new Error("File contains no complete records.");

        // 5. Pick Random Record
        const randomIndex = Math.floor(Math.random() * totalRecords);
        const startOffset = randomIndex * recordLength;
        const record = text.substring(startOffset, startOffset + recordLength);

        console.log(`Selected record #${randomIndex}: ${record}`);

        // 6. Decode Record to Board/FEN
        // ALPHABET index -> 0..63.
        // 0 = a1, 1 = b1 ... 7 = h1, 8 = a2 ...
        
        const grid = Array(8).fill(null).map(() => Array(8).fill(""));

        for (let i = 0; i < recordLength; i++) {
            const char = record[i];
            const val = ALPHABET.indexOf(char);
            if (val === -1) throw new Error(`Invalid character '${char}' in record.`);

            const file = val % 8;       // 0-7 (a-h)
            const rank = Math.floor(val / 8); // 0-7 (1-8)

            // Grid usually indexed [row][col] where row 0 is top (rank 8)
            // row index = 7 - rank
            const gridRow = 7 - rank;
            const gridCol = file;

            const pieceDef = flatList[i];
            const pChar = pieceDef.type.toUpperCase();
            grid[gridRow][gridCol] = (pieceDef.color === 'w' ? pChar : pChar.toLowerCase());
        }

        // 7. Build FEN String
        let fenRows = grid.map(row => {
            let empty = 0;
            let str = "";
            row.forEach(c => {
                if (c === "") empty++;
                else {
                    if (empty > 0) str += empty;
                    empty = 0;
                    str += c;
                }
            });
            if (empty > 0) str += empty;
            return str;
        });
        
        const fen = fenRows.join("/") + " w - - 0 1";
        return fen;
    }

    // --- Helpers ---

    function clearArrows() {
        if (typeof board.removeArrows === "function") board.removeArrows();
    }

    function uciToArrow(uci) {
        if (typeof uci !== "string" || uci.length < 4) return null;
        const from = uci.slice(0, 2);
        const to = uci.slice(2, 4);
        if (!/^[a-h][1-8]$/.test(from) || !/^[a-h][1-8]$/.test(to)) return null;
        return { from, to };
    }

    function categoryToWdl(category) {
        const c = String(category || "").toLowerCase();
        if (c.includes("win")) return 2;
        if (c.includes("loss")) return -2;
        if (c.includes("draw")) return 0;
        return null;
    }

    function drawOutcomeArrows(tbData) {
        clearArrows();
        const moves = Array.isArray(tbData?.moves) ? tbData.moves : [];
        if (!moves.length) return;

        // Map category to WDL and determine if any move is winning for current player
        const movesWithWdl = moves.map(m => ({ ...m, wdl: categoryToWdl(m.category) }));
        
        // Collect unique outcomes present
        const outcomes = new Set(movesWithWdl.map(m => m.wdl));
        
        // If all moves have the same outcome, show nothing
        if (outcomes.size <= 1) return;

        const winningMoves = movesWithWdl.filter(m => m.wdl === -2);
        const hasWinningMove = winningMoves.length > 0;
        
        // Find best DTM among winning moves (lowest absolute value, usually negative or positive depending on API, but we want shortest mate)
        // Lichess DTM: Negative if we are winning? Or just distance?
        // Usually abs(dtm) is distance.
        let bestDtm = Infinity;
        if (hasWinningMove) {
            winningMoves.forEach(m => {
                if (m.dtm !== undefined && m.dtm !== null) {
                    const dist = Math.abs(m.dtm);
                    if (dist < bestDtm) bestDtm = dist;
                }
            });
        }

        for (const m of movesWithWdl) {
            const arrow = uciToArrow(m.uci);
            if (!arrow) continue;
            
            if (m.wdl === null) continue;

            // Filter Logic:
            // 1. Hide Losing moves (wdl === 2)
            if (m.wdl === 2) continue;
            
            // 2. If winning moves exist, hide drawing moves
            if (hasWinningMove && m.wdl === 0) continue;

            // Convert TB WDL to our color WDL
            // Opponent Loss (-2) = Our Win (2) -> Green
            const moveWdl = -m.wdl; 

            let arrowType = null;
            if (moveWdl === 2) {
                // Check if optimal DTM
                let isBest = true;
                if (m.dtm !== undefined && m.dtm !== null) {
                    if (Math.abs(m.dtm) > bestDtm) isBest = false;
                }
                // Best move -> White, Suboptimal -> Green
                arrowType = isBest ? ARROW_WIN_BEST : ARROW_WIN;
            }
            else if (moveWdl === 0) arrowType = ARROW_DRAW;
            else if (moveWdl === -2) arrowType = ARROW_LOSS;

            if (arrowType) {
                board.addArrow(arrowType, arrow.from, arrow.to);
            }
        }
    }

    function getSelectedPieces() {
        const val = document.getElementById("endgameSelect").value;
        const [whitePart, blackPart] = val.split('_');
        const w = whitePart.split(''); // e.g. "KP" -> ['K', 'P']
        const b = blackPart.split(''); // e.g. "KR" -> ['K', 'R']
        return { w, b };
    }

    async function fetchTablebase(fen) {
        const url = TABLEBASE_URL + encodeURIComponent(fen);
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        
        // Normalize
        if (typeof data.wdl === 'undefined' && data.category) {
            const cat = data.category;
            if (cat === 'win') data.wdl = 2;
            else if (cat === 'loss') data.wdl = -2;
            else if (cat === 'draw') data.wdl = 0;
            else data.wdl = 0;
        }
        return data;
    }

    function setStatus(kind, text) {
        el.status.textContent = text;
        el.status.className = "status " + (kind || "");
    }

    function setGuessEnabled(en) {
        el.btnWin.disabled = !en;
        el.btnDraw.disabled = !en;
        el.btnLoss.disabled = !en;
    }

    function updateStreak() {
        el.streak.textContent = streak;
    }

    function wdlToString(wdl) {
        if (wdl > 0) return "Win";
        if (wdl < 0) return "Loss";
        return "Draw";
    }
    
    function updateLinks(fen) {
        el.analyze.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
        el.analyze.removeAttribute("aria-disabled");
    }

  </script>
</body>
</html>
