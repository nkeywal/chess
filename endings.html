<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Endgame Trainer</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/chessboard.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/extensions/arrows/arrows.css">

  <style>
    :root {
      --bg: #0b0f17;
      --panel: #111828;
      --panel2: #0f1624;
      --text: #e7eefc;
      --muted: #a9b6cf;
      --border: rgba(231, 238, 252, 0.12);
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --btn: #1c2a44;
      --btnHover: #243659;
      
      --highlight-win: #2ecc71;
      --highlight-loss: #ff5c5c;
      --highlight-draw: #ffcc66;

      --pagePad: 24px;
      --cardPad: 16px;
      --gap: 18px;
      --boardSize: min(600px, 65vh);
    }

    @media (max-width: 900px) {
      :root { --gap: 14px; --boardSize: min(580px, 60vh); }
      body { place-items: start center; }
    }

    @media (max-width: 600px) {
      :root {
        --pagePad: 10px;
        --cardPad: 10px;
        --gap: 10px;
        --boardSize: min(96vw, 46svh, 500px);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 50% 0%, #162445 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100svh;
      padding: var(--pagePad);
      display: grid;
      place-items: center;
    }

    .app {
      width: min(1000px, 100%);
      display: grid;
      gap: var(--gap);
    }

    header {
      display: flex;
      gap: 12px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: var(--gap);
      align-items: start;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .boardCard {
      padding: var(--cardPad);
      display: grid;
      place-items: center;
    }

    .boardSizer {
      width: min(100%, var(--boardSize));
      height: min(100%, var(--boardSize));
      overflow: visible;
    }

    #board {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden;
    }

    .sideCard {
      padding: var(--cardPad);
      display: grid;
      gap: 10px;
    }

    .status {
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
      color: var(--muted);
      font-size: 14px;
      line-height: 1.35;
      white-space: pre-wrap;
      text-align: center;
      min-height: 3em;
      display: flex; align-items: center; justify-content: center;
    }
    .status.ok   { border-color: rgba(46, 204, 113, 0.35); color: rgba(46, 204, 113, 0.95); }
    .status.bad  { border-color: rgba(255, 92, 92, 0.35); color: rgba(255, 92, 92, 0.95); }
    .status.warn { border-color: rgba(255, 204, 102, 0.35); color: rgba(255, 204, 102, 0.95); }

    .btnRow {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .btnRow2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button, a.linkBtn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 750;
      letter-spacing: 0.2px;
      transition: transform 0.04s ease, background 0.15s ease, opacity 0.15s ease;
      text-align: center;
      text-decoration: none;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      min-height: 44px;
      font-size: 0.95rem;
    }
    button:hover, a.linkBtn:hover { background: var(--btnHover); }
    button:active, a.linkBtn:active { transform: translateY(1px); }
    button:disabled, a.linkBtn[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .btn-win { border-color: rgba(46, 204, 113, 0.4); }
    .btn-draw { border-color: rgba(255, 204, 102, 0.4); }
    .btn-loss { border-color: rgba(255, 92, 92, 0.4); }

    details {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
      overflow: hidden;
    }
    summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      color: var(--muted);
      font-weight: 800;
      user-select: none;
    }
    summary::-webkit-details-marker { display: none; }

    .detailsBody {
      padding: 10px 12px 12px 12px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }

    .piece-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-width: 100px;
    }
    .piece-group strong { color: var(--text); margin-bottom: 5px; display:block; }
    .piece-group label { display: flex; align-items: center; gap: 8px; color: var(--muted); font-size: 0.9rem; cursor: pointer; }
    .piece-group input { cursor: pointer; }

    .streak-display {
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
        margin-bottom: 5px;
    }
    .streak-display strong { color: var(--text); }
    
    .hidden { display: none !important; }

    .marker-selected {
        fill: rgba(255, 255, 255, 0.4);
        stroke: none;
        pointer-events: none;
    }

    /* --- Pretty Arrows --- */
    /* Link lines to custom markers defined in HTML */
    .arrow-win line { 
        stroke: #4ade80 !important; 
        marker-end: url(#arrowHeadWin) !important;
    }
    .arrow-draw line { 
        stroke: #facc15 !important; 
        marker-end: url(#arrowHeadDraw) !important;
    }
    .arrow-loss line { 
        stroke: #f87171 !important; 
        marker-end: url(#arrowHeadLoss) !important;
    }

    /* Common visual finish */
    .arrow-win, .arrow-draw, .arrow-loss {
        opacity: 0.9;
        filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
    }
    
    /* Ensure the lines have round caps */
    .arrow-win line, .arrow-draw line, .arrow-loss line {
        stroke-linecap: round;
    }

    /* Remove old marker styling attempts */
    #board svg marker path,
    #board svg marker polygon {
        stroke-width: 0;
    }

    /* Fix mobile vertical jump by overriding body alignment at the end of cascade */
    @media (max-width: 900px) {
      body { place-items: start center; }
    }

  </style>
</head>

<body>
  <!-- Custom SVG Markers for Arrows -->
  <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" aria-hidden="true">
    <defs>
      <marker id="arrowHeadWin" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#4ade80" />
      </marker>
      <marker id="arrowHeadDraw" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#facc15" />
      </marker>
      <marker id="arrowHeadLoss" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#f87171" />
      </marker>
    </defs>
  </svg>

  <div class="app">
    <header>
      <h1>Endgame Trainer</h1>
    </header>

    <section class="layout">
      <div class="card boardCard">
        <div class="boardSizer">
          <div id="board" aria-label="Chessboard"></div>
        </div>
      </div>

      <div class="card sideCard">
        
        <details id="setupDetails">
          <summary>⚙️ Setup Pieces</summary>
          <div class="detailsBody">
            <div class="piece-group">
                <strong>White</strong>
                <label><input type="checkbox" name="white-pieces" value="K" checked disabled> King</label>
                <label><input type="checkbox" name="white-pieces" value="Q"> Queen</label>
                <label><input type="checkbox" name="white-pieces" value="R"> Rook</label>
                <label><input type="checkbox" name="white-pieces" value="B"> Bishop</label>
                <label><input type="checkbox" name="white-pieces" value="N"> Knight</label>
                <label><input type="checkbox" name="white-pieces" value="P" checked> Pawn</label>
                <label><input type="checkbox" name="white-pieces" value="P"> 2nd Pawn</label>
            </div>
            <div class="piece-group">
                <strong>Black</strong>
                <label><input type="checkbox" name="black-pieces" value="K" checked disabled> King</label>
                <label><input type="checkbox" name="black-pieces" value="Q"> Queen</label>
                <label><input type="checkbox" name="black-pieces" value="R" checked> Rook</label>
                <label><input type="checkbox" name="black-pieces" value="B"> Bishop</label>
                <label><input type="checkbox" name="black-pieces" value="N"> Knight</label>
                <label><input type="checkbox" name="black-pieces" value="P"> Pawn</label>
                <label><input type="checkbox" name="black-pieces" value="P"> 2nd Pawn</label>
            </div>
            <div style="width:100%; text-align:center; font-size:0.8rem; color:var(--muted); margin-top:5px;">Max 7 pieces total.</div>
          </div>
        </details>

        <div class="streak-display">
            Streak: <strong id="streak">0</strong>
        </div>

        <div id="status" class="status">Initializing...</div>

        <div class="btnRow" id="guessControls">
          <button class="btn-win" id="btnWin">Win</button>
          <button class="btn-draw" id="btnDraw">Draw</button>
          <button class="btn-loss" id="btnLoss">Loss</button>
        </div>

        <button id="btnPlayAgain" class="hidden" style="background:var(--highlight-win); border:none; color:white;">Play Again &rarr;</button>

        <div class="btnRow2">
          <button id="btnNew">New Position</button>
          <a id="analyzeLink" class="linkBtn" href="#" target="_blank" rel="noopener noreferrer" aria-disabled="true">Analyze</a>
        </div>
      </div>
    </section>
  </div>

  <script type="module">
    // Debug helper
    window.onerror = function(msg, url, line, col, error) {
       document.getElementById("status").textContent = "JS Error: " + msg;
       document.getElementById("status").className = "status bad";
    };

    import { Chessboard, COLOR, BORDER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/Chessboard.js";
    import { Arrows, ARROW_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/extensions/arrows/Arrows.js";
    import { Markers, MARKER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/extensions/markers/Markers.js";
    import { Chess } from "https://cdn.jsdelivr.net/npm/chess.js@1.0.0-beta.7/+esm";

    const MARKER_SELECTED = { class: "marker-selected", slice: "markerSquare" };
    const ARROW_WIN = { ...ARROW_TYPE.default, class: "arrow-win" };
    const ARROW_DRAW = { ...ARROW_TYPE.default, class: "arrow-draw" };
    const ARROW_LOSS = { ...ARROW_TYPE.default, class: "arrow-loss" };

    console.log("Imports loaded");
    document.getElementById("status").textContent = "Imports loaded...";
    
    const TABLEBASE_URL = "https://tablebase.lichess.ovh/standard?fen=";

    // --- DOM Elements ---
    const el = {
      status: document.getElementById("status"),
      streak: document.getElementById("streak"),
      btnWin: document.getElementById("btnWin"),
      btnDraw: document.getElementById("btnDraw"),
      btnLoss: document.getElementById("btnLoss"),
      btnNew: document.getElementById("btnNew"),
      btnPlayAgain: document.getElementById("btnPlayAgain"),
      analyze: document.getElementById("analyzeLink"),
      guessControls: document.getElementById("guessControls"),
    };

    // --- State ---
    let chess = new Chess();
    let board = null;
    let currentFen = "";
    let initialFen = "";
    let currentTbData = null;
    let streak = 0;
    let isUserTurn = false;
    let gameActive = false;
    let currentObjective = null;
    let selectedSquare = null;

    // --- Init Board ---
    board = new Chessboard(document.getElementById("board"), {
      assetsUrl: "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/",
      position: "8/8/8/8/8/8/8/8", // "empty" keyword crashes, use explicit FEN
      orientation: COLOR.white,
      style: {
        pieces: { file: "pieces/standard.svg" },
        borderType: BORDER_TYPE.frame
      },
      extensions: [{ class: Arrows }, { class: Markers }]
    });

    board.enableMoveInput((event) => {
        if (!isUserTurn || !gameActive) return false;

        switch (event.type) {
            case "moveInputStarted":
                const p = chess.get(event.square);
                const isOurPiece = p && p.color === 'w';
                if (isOurPiece) {
                    if (selectedSquare === event.square) {
                        selectSquare(null);
                        return false; // Stop interaction on deselect
                    } else {
                        selectSquare(event.square);
                        return true;
                    }
                }
                return false;
                
            case "validateMoveInput":
                try {
                    const temp = new Chess(chess.fen());
                    const m = temp.move({ from: event.squareFrom, to: event.squareTo, promotion: 'q' });
                    return !!m;
                } catch (e) { return false; }
                
            case "moveInputFinished":
                // Defer clearing to ensure it happens after any internal event handling
                setTimeout(() => selectSquare(null), 10);
                if (event.legalMove) {
                    handleUserMove(event.squareFrom, event.squareTo);
                }
                return true;
        }
    });

    // --- Event Listeners ---
    el.btnWin.addEventListener("click", () => handleGuess(2)); // Win for White
    el.btnDraw.addEventListener("click", () => handleGuess(0));
    el.btnLoss.addEventListener("click", () => handleGuess(-2));
    
    el.btnNew.addEventListener("click", startNewGame);
    el.btnPlayAgain.addEventListener("click", startNewGame);

    function selectSquare(sq) {
        board.removeMarkers(MARKER_SELECTED);
        selectedSquare = sq;
        if (selectedSquare) {
            board.addMarker(MARKER_SELECTED, selectedSquare);
        }
    }

    // --- Persistence ---
    function saveSettings() {
        try {
            const w = Array.from(document.querySelectorAll('input[name="white-pieces"]')).map(el => el.checked);
            const b = Array.from(document.querySelectorAll('input[name="black-pieces"]')).map(el => el.checked);
            localStorage.setItem("endgame-trainer-white", JSON.stringify(w));
            localStorage.setItem("endgame-trainer-black", JSON.stringify(b));
        } catch(e) { console.warn("Could not save settings", e); }
    }

    function loadSettings() {
        try {
            const w = JSON.parse(localStorage.getItem("endgame-trainer-white"));
            const b = JSON.parse(localStorage.getItem("endgame-trainer-black"));
            
            if (w) {
                const inputs = document.querySelectorAll('input[name="white-pieces"]');
                w.forEach((val, i) => { if(inputs[i] && !inputs[i].disabled) inputs[i].checked = val; });
            }
            if (b) {
                const inputs = document.querySelectorAll('input[name="black-pieces"]');
                b.forEach((val, i) => { if(inputs[i] && !inputs[i].disabled) inputs[i].checked = val; });
            }
        } catch(e) { console.warn("Could not load settings", e); }
    }
    
    // Init Persistence
    loadSettings();
    document.querySelectorAll('.piece-group input').forEach(el => el.addEventListener('change', saveSettings));

    // Start
    console.log("Starting game loop...");
    startNewGame();


    // --- Core Logic ---

    async function startNewGame() {
        console.log("startNewGame called");
        gameActive = false;
        isUserTurn = false;
        currentTbData = null;
        clearArrows();
        selectSquare(null);
        setGuessEnabled(false);
        if(el.btnPlayAgain) el.btnPlayAgain.classList.add("hidden");
        if(el.guessControls) el.guessControls.classList.remove("hidden");
        setStatus("warn", "Generating position...");
        
        try {
            console.log("Generating valid position...");
            const fen = await generateValidPosition();
            console.log("Position generated:", fen);
            
            currentFen = fen;
            initialFen = fen;
            console.log("Loading into Chess.js...");
            try {
                chess.load(fen);
            } catch(loadErr) {
                throw new Error("Chess.load failed on FEN: " + fen + " :: " + loadErr);
            }
            
            console.log("Setting board position...");
            await board.setPosition(fen, true);
            
            // Get initial TB data
            console.log("Fetching TB data...");
            currentTbData = await fetchTablebase(fen);
            console.log("TB Data received", currentTbData);
            
            // Set Objective
            // normalize wdl from category if needed handled in fetchTablebase
            
            updateLinks(initialFen);
            setStatus(null, "Your Turn: Guess result (Win/Draw/Loss) or Play a move.");
            setGuessEnabled(true);
            gameActive = true;
            isUserTurn = true;

        } catch (e) {
            console.error(e);
            setStatus("bad", "Error: " + e.message);
        }
    }

    async function handleUserMove(from, to) {
        clearArrows();
        // Double check: clear any selection immediately
        selectSquare(null);

        if (!gameActive) return;

        // Move is valid (already checked by cm-chessboard)
        chess.move({ from, to, promotion: 'q' });
        
        isUserTurn = false;
        setStatus("warn", "Thinking...");

        // Evaluate Move
        const prevWdl = currentTbData.wdl;
        
        // Fetch new data
        try {
            const newFen = chess.fen();
            console.log("Fetching response for FEN:", newFen);
            const newData = await fetchTablebase(newFen);
            console.log("Response received:", newData);
            
            // Check blunder
            // White moved. Now Black to move.
            // If White was Winning (2), Black should be Losing (-2).
            // If White was Drawing (0), Black should be Drawing (0).
            
            let failed = false;
            let msg = "";

            if (prevWdl === 2) { // We were winning
                 if (newData.wdl !== -2) { // Opponent not losing
                     failed = true;
                     msg = "Blunder! You turned a Win into a Draw/Loss.";
                 }
            } else if (prevWdl === 0) { // Drawing
                 if (newData.wdl === 2) { // Opponent Winning
                     failed = true;
                     msg = "Blunder! You turned a Draw into a Loss.";
                 }
            }
            
            if (failed) {
                endGame(false, msg);
                // Revert board to show? No, keep it.
                return;
            }

            if (chess.isGameOver()) {
                handleGameOver();
                return;
            }

            // Computer Reply (Best Move)
            if (newData.moves && newData.moves.length > 0) {
                console.log("Computer found move:", newData.moves[0].uci);
                const bestMove = newData.moves[0]; // Syzygy best move
                const uci = bestMove.uci;
                const fromC = uci.slice(0, 2);
                const toC = uci.slice(2, 4);
                
                chess.move({ from: fromC, to: toC, promotion: 'q' });
                await board.setPosition(chess.fen(), true);
                
                if (chess.isGameOver()) {
                    handleGameOver();
                    return;
                }
                
                // Update state
                currentFen = chess.fen();
                currentTbData = await fetchTablebase(currentFen);
                
                isUserTurn = true;
                setStatus(null, "Your Turn");
                // updateLinks removed
            } else {
                handleGameOver();
            }

        } catch (e) {
            setStatus("bad", "Error: " + e.message);
        }
    }

    function handleGuess(guessWdl) {
        if (!gameActive) return;
        drawOutcomeArrows(currentTbData);
        
        const actualWdl = currentTbData.wdl;
        // Map category to wdl if needed, but fetchTablebase handles it
        
        let correct = (guessWdl === actualWdl);
        
        if (correct) {
            streak++;
            updateStreak();
            setStatus("ok", `Correct! It is a ${wdlToString(actualWdl)}. Keep playing if you want.`);
            setGuessEnabled(false); // Disable buttons but allow play
            // el.btnPlayAgain.classList.remove("hidden");
            el.guessControls.classList.add("hidden");
        } else {
            streak = 0;
            updateStreak();
            setStatus("bad", `Wrong. It is a ${wdlToString(actualWdl)}.`);
            endGame(false, `Wrong. It is a ${wdlToString(actualWdl)}.`);
        }
    }

    function handleGameOver() {
        let success = false;
        let msg = "";

        if (chess.isCheckmate()) {
            if (chess.turn() === 'b') { // White moved last => White mated Black
                success = true;
                msg = "Checkmate! You Won!";
            } else {
                // Black mated White
                // Only success if objective was Loss (unlikely)
                success = (currentTbData.wdl === -2);
                msg = success ? "Checkmate (Expected Loss)" : "Checkmate! You Lost.";
            }
        } else if (chess.isStalemate()) {
            // Stalemate is a Draw.
            // Success if objective was Draw (0) or Loss (-2 - saving a loss is good?). 
            // Usually if WDL=0, Stalemate is success.
            success = (currentTbData.wdl <= 0);
            msg = "Stalemate!";
        } else {
            // Insufficient material, 50-move, etc. => Draw
            success = (currentTbData.wdl <= 0);
            msg = "Game Over (Draw).";
        }

        if (success) {
            streak++;
            updateStreak();
            setStatus("ok", msg); // Green
        } else {
            // Reset streak on failure
            streak = 0;
            updateStreak();
            setStatus("bad", msg); // Red
        }
        
        endGame(success, msg);
    }

    function endGame(success, msg) {
        gameActive = false;
        isUserTurn = false;
        setStatus(success ? "ok" : "bad", msg);
        setGuessEnabled(false);
        // el.btnPlayAgain.classList.remove("hidden"); // Redundant
        el.guessControls.classList.add("hidden");
        if (!success) {
            streak = 0;
            updateStreak();
        }
    }

    // --- Generation & Validation Logic ---

    async function generateValidPosition() {
        // 1. Determine Piece Composition from UI
        let { w, b } = getSelectedPieces();
        
        // Ensure Kings
        if(!w.includes('K')) w.push('K');
        if(!b.includes('K')) b.push('K');

        // 2. Identify Scenario
        const allPieces = [...w, ...b].map(p => p.toUpperCase()).sort().join('');

        // K+R vs K+P => K,R,K,P => KKP R
        let scenario = null;
        let preferredResult = null;
        let maxPreferredAttempts = 0;

        if (allPieces === "KKPR") {
            scenario = "KR_KP";
            preferredResult = 0; // Prefer Draw
            maxPreferredAttempts = 5;
        }

        let attempts = 0;
        const MAX_ATTEMPTS = 2000;
        let validCandidatesFound = 0;
        let lastValidFen = null;

        while (attempts < MAX_ATTEMPTS) {
            attempts++;
            
            // --- Step 1: Generation ---
            let fen;

            if (scenario === "KR_KP") {
                fen = randomPlacement_KR_KP(); // Specialized placement
            } else {
                fen = randomPlacement(w, b); // Generic placement
            }
            
            const ch = new Chess();
            try {
                ch.load(fen);
            } catch (e) { continue; }

            // --- Step 2: Generic Pre-TB Validation ---
            if (!validateGenericPreTB(ch)) continue;

            // --- Step 3: Specific Pre-TB Validation ---
            if (scenario === "KR_KP") {
                if (!validateSpecificPreTB_KR_KP(ch)) continue;
            }

            // --- Step 4: Tablebase Fetch ---
            let tbData;
            try {
                tbData = await fetchTablebase(fen);
            } catch (e) { continue; }

            // --- Step 5: Generic Post-TB Validation ---
            if (!validateGenericPostTB(ch, tbData)) continue;

            // --- Step 6: Specific Post-TB Validation ---
            if (scenario === "KR_KP") {
                if (!validateSpecificPostTB_KR_KP(ch, tbData)) continue;
            }

            // --- Success / Preference Logic ---
            lastValidFen = fen; // Save as fallback

            if (preferredResult !== null) {
                if (tbData.wdl === preferredResult) {
                    return fen; // Perfect match
                } else {
                    validCandidatesFound++;
                    if (validCandidatesFound > maxPreferredAttempts) {
                         return fen; // Good enough
                    }
                    // Else loop again to try finding preferred result
                    continue; 
                }
            }

            return fen;
        }

        if (lastValidFen) {
            return lastValidFen;
        }

        throw new Error("Could not generate a valid position after " + MAX_ATTEMPTS + " attempts.");
    }

    // --- Specialized Placement for KR vs KP (Updated Policy) ---
    function randomPlacement_KR_KP() {
        const files = "abcdefgh";
        const grid = Array(8).fill(null).map(() => Array(8).fill(""));
        const used = new Set();
        
        const isSchemaA = Math.random() < 0.5;
        
        const pawnColor = isSchemaA ? 'b' : 'w';
        const rookColor = isSchemaA ? 'w' : 'b';
        const kpColor = pawnColor;
        const krColor = rookColor;

        // 1. Place Pawn (P)
        // Rang: 6,7 (W) or 2,3 (B)
        let pRank;
        if (pawnColor === 'w') {
            pRank = Math.random() < 0.5 ? 6 : 7;
        } else {
            pRank = Math.random() < 0.5 ? 2 : 3;
        }

        // Fichier: 50% {a,h}, 50% {b-g}
        let pFile;
        if (Math.random() < 0.5) {
            // Edge (a, h) -> indices 0, 7
            pFile = Math.random() < 0.5 ? 0 : 7;
        } else {
            // Middle (b-g) -> indices 1-6
            pFile = Math.floor(Math.random() * 6) + 1;
        }
        
        const pSq = files[pFile] + pRank;
        used.add(pSq);
        grid[8 - pRank][pFile] = (pawnColor === 'w' ? 'P' : 'p');

        // 2. Place Kp (Pawn's King)
        // dist(Kp, P) <= 2
        const kpSq = getRandomSquareNear(pFile, pRank, 2, used);
        if (!kpSq) return randomPlacement_KR_KP(); // Retry
        used.add(kpSq.sq);
        grid[8 - kpSq.r][kpSq.f] = (kpColor === 'w' ? 'K' : 'k');

        // 3. Place Kr (Rook's King)
        // 3 <= dist(Kr, P) <= 6
        const krSq = getRandomSquareRing(pFile, pRank, 3, 6, used);
        if (!krSq) return randomPlacement_KR_KP(); // Retry
        used.add(krSq.sq);
        grid[8 - krSq.r][krSq.f] = (krColor === 'w' ? 'K' : 'k');

        // 4. Place Rook (R)
        // Any free square
        const validRookSqs = [];
        for(let r=1; r<=8; r++) {
            for(let f=0; f<8; f++) {
                const sq = files[f] + r;
                if (!used.has(sq)) {
                    validRookSqs.push({r, f, sq});
                }
            }
        }
        
        if (validRookSqs.length === 0) return randomPlacement_KR_KP(); // Retry

        const rPlace = validRookSqs[Math.floor(Math.random() * validRookSqs.length)];
        grid[8 - rPlace.r][rPlace.f] = (rookColor === 'w' ? 'R' : 'r');

        // Build FEN
        let fenRows = grid.map(row => {
            let empty = 0;
            let str = "";
            row.forEach(c => {
                if (c === "") empty++;
                else {
                    if (empty > 0) str += empty;
                    empty = 0;
                    str += c;
                }
            });
            if (empty > 0) str += empty;
            return str;
        });
        
        return fenRows.join("/") + " w - - 0 1";
    }

    // Helper for specialized placement
    function getRandomSquareNear(cenF, cenR, maxDist, usedSet) {
        const candidates = [];
        const files = "abcdefgh";
        for (let r=1; r<=8; r++) {
            for (let f=0; f<8; f++) {
                const dist = Math.max(Math.abs(r - cenR), Math.abs(f - cenF));
                if (dist > 0 && dist <= maxDist) {
                    const sq = files[f] + r;
                    if (!usedSet.has(sq)) candidates.push({r, f, sq});
                }
            }
        }
        if (!candidates.length) return null;
        return candidates[Math.floor(Math.random() * candidates.length)];
    }

    function getRandomSquareRing(cenF, cenR, minDist, maxDist, usedSet) {
        const candidates = [];
        const files = "abcdefgh";
        for (let r=1; r<=8; r++) {
            for (let f=0; f<8; f++) {
                const dist = Math.max(Math.abs(r - cenR), Math.abs(f - cenF));
                if (dist >= minDist && dist <= maxDist) {
                    const sq = files[f] + r;
                    if (!usedSet.has(sq)) candidates.push({r, f, sq});
                }
            }
        }
        if (!candidates.length) return null;
        return candidates[Math.floor(Math.random() * candidates.length)];
    }


    // --- Layer 1: Spec — règles génériques (universelles) ---

    function validateGenericPreTB(ch) {
        // 1.1 Légalité
        if (ch.turn() !== 'w') return false; 
        
        const board = ch.board();
        for (let c = 0; c < 8; c++) {
            if (board[0][c] && board[0][c].type === 'p') return false;
            if (board[7][c] && board[7][c].type === 'p') return false;
        }

        // White in check?
        if (ch.inCheck()) return false; 
        
        // Black in check? (Flip turn)
        const fenParts = ch.fen().split(' ');
        fenParts[1] = 'b';
        const chB = new Chess();
        try {
            chB.load(fenParts.join(' '));
            if (chB.inCheck()) return false;
        } catch(e) { return false; }

        // 1.2 Structure (universel, peu contraignant)
        // mobilityW < 3
        const mobW = ch.moves().length;
        if (mobW < 3) return false;

        // mobilityB < 3
        const mobB = chB.moves().length;
        if (mobB < 3) return false;

        return true;
    }

    function validateGenericPostTB(ch, data) {
        // 1.3 Tablebase minimale (1 appel)
        
        const moves = data.moves || [];
        if (moves.length === 0) return false;
        if (typeof data.wdl !== 'number') return false;

        // Trivialité immédiate
        // si dtz présent : abs(dtz) < 2
        if (data.dtz !== undefined && data.dtz !== null) {
            if (Math.abs(data.dtz) < 2) return false;
        } 
        // sinon si dtm présent : abs(dtm) < 4
        else if (data.dtm !== undefined && data.dtm !== null) {
            if (Math.abs(data.dtm) < 4) return false;
        } 
        // sinon rejet
        else {
            return false;
        }

        return true;
    }

    // --- Layer 2: Spec — règles spécifiques K+R vs K+P ---

    function validateSpecificPreTB_KR_KP(ch) {
        // 2.2 Contraintes d’acceptation additionnelles (K+R vs K+P)
        const pieces = getPieceLocations(ch);
        const pPawn = pieces.find(p => p.type === 'p');
        const pRook = pieces.find(p => p.type === 'r');
        
        if (!pPawn || !pRook) return false;

        // Capture immédiate du pion par le camp de la tour (roi ou tour)
        const rookSide = pRook.color;
        if (ch.turn() === rookSide) {
             const moves = ch.moves({ verbose: true });
             if (moves.some(m => m.captured === 'p')) return false;
        }

        // Promotion immédiate du pion par le camp du pion
        const pawnSide = pPawn.color;
        if (ch.turn() === pawnSide) {
             const moves = ch.moves({ verbose: true });
             if (moves.some(m => m.promotion)) return false;
        }

        return true;
    }

    function validateSpecificPostTB_KR_KP(ch, data) {
        // 2.3 Tablebase additionnelle (K+R vs K+P)

        // Trivialité modérée
        // si dtz présent : abs(dtz) < 4
        if (data.dtz !== undefined && data.dtz !== null) {
            if (Math.abs(data.dtz) < 4) return false;
        } 
        // sinon si dtm présent : abs(dtm) < 6
        else if (data.dtm !== undefined && data.dtm !== null) {
            if (Math.abs(data.dtm) < 6) return false;
        } 
        // sinon rejet
        else {
            return false;
        }

        return true;
    }


    // --- Helpers ---

    function randomPlacement(wPieces, bPieces) {
        const files = "abcdefgh";
        const used = new Set();
        const getSq = () => files[Math.floor(Math.random()*8)] + (Math.floor(Math.random()*8)+1);
        
        let list = [
            ...wPieces.map(t => ({t: t.toLowerCase(), c: 'w'})),
            ...bPieces.map(t => ({t: t.toLowerCase(), c: 'b'}))
        ];

        const board = [];
        
        for(let p of list) {
             let sq;
             let tries = 0;
             while(tries < 100) {
                 sq = getSq();
                 if(!used.has(sq)) {
                     // Basic Pawn constraints (no Rank 1 or 8)
                     // Although validateGenericPre checks this, doing it here saves iterations
                     if (p.t === 'p') {
                         if (sq[1] === '1' || sq[1] === '8') { tries++; continue; }
                     }
                     break;
                 }
                 tries++;
             }
             if(sq) {
                 used.add(sq);
                 board.push({sq, ...p});
             }
        }
        
        // Build FEN
        const grid = Array(8).fill(null).map(() => Array(8).fill(""));
        board.forEach(p => {
            const f = files.indexOf(p.sq[0]);
            const r = 8 - parseInt(p.sq[1]);
            grid[r][f] = (p.c === 'w') ? p.t.toUpperCase() : p.t.toLowerCase();
        });
        
        let fenRows = grid.map(row => {
            let empty = 0;
            let str = "";
            row.forEach(c => {
                if (c === "") empty++;
                else {
                    if (empty > 0) str += empty;
                    empty = 0;
                    str += c;
                }
            });
            if (empty > 0) str += empty;
            return str;
        });
        
        return fenRows.join("/") + " w - - 0 1";
    }

    function getPieceLocations(ch) {
        const pieces = [];
        const board = ch.board();
        const files = "abcdefgh";
        for (let r=0; r<8; r++) {
            for (let c=0; c<8; c++) {
                if (board[r][c]) {
                    const sq = files[c] + (8-r);
                    pieces.push({ ...board[r][c], square: sq, r: 8-r, f: c+1 }); // r: 1-8, f: 1-8
                }
            }
        }
        return pieces;
    }

    function getChebyshevDistance(sq1, sq2) {
        const f1 = sq1.charCodeAt(0);
        const r1 = parseInt(sq1[1]);
        const f2 = sq2.charCodeAt(0);
        const r2 = parseInt(sq2[1]);
        return Math.max(Math.abs(f1 - f2), Math.abs(r1 - r2));
    }

    function getBoundingBoxArea(pieces) {
        if (pieces.length === 0) return 0;
        let minR = 9, maxR = 0, minF = 9, maxF = 0;
        pieces.forEach(p => {
            if (p.r < minR) minR = p.r;
            if (p.r > maxR) maxR = p.r;
            if (p.f < minF) minF = p.f;
            if (p.f > maxF) maxF = p.f;
        });
        const w = (maxF - minF + 1);
        const h = (maxR - minR + 1);
        return w * h;
    }

    function getRank(sq) {
        return parseInt(sq[1]);
    }

    function isCaptureOrPromotion(ch, uci) {
        const from = uci.slice(0, 2);
        const to = uci.slice(2, 4);
        const promo = uci.length > 4;
        if (promo) return true;
        
        const piece = ch.get(to);
        if (piece) return true; // Capture
        
        // En passant?
        if (ch.get(from).type === 'p' && from[0] !== to[0] && !piece) return true;
        
        return false;
    }

    function isNaturalMove(ch, uci) {
        // Natural = Capture OR Promotion OR Check
        if (isCaptureOrPromotion(ch, uci)) return true;
        
        // Check?
        // We need to see if the move gives check.
        // Expensive way: make move, check inCheck, undo.
        // Efficient way: check SAN from move generation or just do it.
        const temp = new Chess(ch.fen());
        const m = temp.move({ from: uci.slice(0,2), to: uci.slice(2,4), promotion: uci.slice(4) || undefined });
        if (m && m.san.includes('+')) return true;

        return false;
    }

    function clearArrows() {
        if (typeof board.removeArrows === "function") board.removeArrows();
    }

    function uciToArrow(uci) {
        if (typeof uci !== "string" || uci.length < 4) return null;
        const from = uci.slice(0, 2);
        const to = uci.slice(2, 4);
        if (!/^[a-h][1-8]$/.test(from) || !/^[a-h][1-8]$/.test(to)) return null;
        return { from, to };
    }

    function categoryToWdl(category) {
        const c = String(category || "").toLowerCase();
        if (c.includes("win")) return 2;
        if (c.includes("loss")) return -2;
        if (c.includes("draw")) return 0;
        return null;
    }

    function drawOutcomeArrows(tbData) {
        clearArrows();
        const moves = Array.isArray(tbData?.moves) ? tbData.moves : [];
        if (!moves.length) return;

        for (const m of moves) {
            const arrow = uciToArrow(m.uci);
            if (!arrow) continue;
            
            const baseWdl = categoryToWdl(m.category); // Raw WDL from category
            if (baseWdl === null) continue;

            // Invert the WDL to match user's observed colors (winning moves appearing red, losing moves appearing green).
            const moveWdl = -baseWdl; 

            let arrowType = null;
            if (moveWdl === 2) arrowType = ARROW_WIN;
            else if (moveWdl === 0) arrowType = ARROW_DRAW;
            else if (moveWdl === -2) arrowType = ARROW_LOSS;

            if (arrowType) {
                board.addArrow(arrowType, arrow.from, arrow.to);
            }
        }
    }

    function getSelectedPieces() {
        const w = Array.from(document.querySelectorAll('input[name="white-pieces"]:checked')).map(c=>c.value);
        const b = Array.from(document.querySelectorAll('input[name="black-pieces"]:checked')).map(c=>c.value);
        return { w, b };
    }

    async function fetchTablebase(fen) {
        const url = TABLEBASE_URL + encodeURIComponent(fen);
        const res = await fetch(url);
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        
        // Normalize
        if (typeof data.wdl === 'undefined' && data.category) {
            const cat = data.category;
            if (cat === 'win') data.wdl = 2;
            else if (cat === 'loss') data.wdl = -2;
            else if (cat === 'draw') data.wdl = 0;
            else data.wdl = 0;
        }
        return data;
    }

    function setStatus(kind, text) {
        el.status.textContent = text;
        el.status.className = "status " + (kind || "");
    }

    function setGuessEnabled(en) {
        el.btnWin.disabled = !en;
        el.btnDraw.disabled = !en;
        el.btnLoss.disabled = !en;
    }

    function updateStreak() {
        el.streak.textContent = streak;
    }

    function wdlToString(wdl) {
        if (wdl > 0) return "Win";
        if (wdl < 0) return "Loss";
        return "Draw";
    }
    
    function updateLinks(fen) {
        el.analyze.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
        el.analyze.removeAttribute("aria-disabled");
    }

  </script>
</body>
</html>
