<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trivial Endgames</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/chessboard.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/extensions/arrows/arrows.css">

  <style>
    :root {
      --bg: #0b0f17;
      --panel: #111828;
      --panel2: #0f1624;
      --text: #e7eefc;
      --muted: #a9b6cf;
      --border: rgba(231, 238, 252, 0.12);
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --btn: #1c2a44;
      --btnHover: #243659;
      
      --highlight-win: #2ecc71;
      --highlight-loss: #ff5c5c;
      --highlight-draw: #ffcc66;

      --pagePad: 24px;
      --cardPad: 16px;
      --gap: 18px;
      --boardSize: min(600px, 65vh);
    }

    @media (max-width: 900px) {
      :root { --gap: 14px; --boardSize: min(580px, 60vh); }
      body { place-items: start center; }
    }

    @media (max-width: 600px) {
      :root {
        --pagePad: 10px;
        --cardPad: 10px;
        --gap: 10px;
        --boardSize: min(96vw, 46svh, 500px);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 50% 0%, #162445 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100svh;
      padding: var(--pagePad);
      display: grid;
      place-items: center;
    }

    .app {
      width: min(1000px, 100%);
      display: grid;
      gap: var(--gap);
    }

    header {
      display: flex;
      gap: 12px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: var(--gap);
      align-items: start;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .boardCard {
      padding: 0; /* Removed padding for full-bleed board */
      display: grid;
      place-items: center;
      border: none; /* Optional: remove card border if desired, but padding=0 usually fixes the 'frame' look */
      background: transparent; /* Remove card background so only board shows */
      box-shadow: none;
    }

    /* Force hide cm-chessboard border if JS setting fails */
    .cm-chessboard .border { 
        display: none !important; 
        stroke: none !important;
    }

    .boardSizer {
      width: min(100%, var(--boardSize));
      height: min(100%, var(--boardSize));
      overflow: visible;
    }

    #board {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden;
    }

    .sideCard {
      padding: var(--cardPad);
      display: grid;
      gap: 10px;
    }

    .status {
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
      color: var(--muted);
      font-size: 14px;
      line-height: 1.35;
      white-space: pre-wrap;
      text-align: center;
      min-height: 3em;
      display: flex; align-items: center; justify-content: center;
    }
    .status.ok   { border-color: rgba(46, 204, 113, 0.35); color: rgba(46, 204, 113, 0.95); }
    .status.bad  { border-color: rgba(255, 92, 92, 0.35); color: rgba(255, 92, 92, 0.95); }
    .status.warn { border-color: rgba(255, 204, 102, 0.35); color: rgba(255, 204, 102, 0.95); }

    .btnRow {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .btnRow2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button, a.linkBtn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 750;
      letter-spacing: 0.2px;
      transition: transform 0.04s ease, background 0.15s ease, opacity 0.15s ease;
      text-align: center;
      text-decoration: none;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      min-height: 44px;
      font-size: 0.95rem;
    }
    button:hover, a.linkBtn:hover { background: var(--btnHover); }
    button:active, a.linkBtn:active { transform: translateY(1px); }
    button:disabled, a.linkBtn[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .btn-win { border-color: rgba(46, 204, 113, 0.4); }
    .btn-draw { border-color: rgba(255, 204, 102, 0.4); }
    .btn-loss { border-color: rgba(255, 92, 92, 0.4); }

    details {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
      overflow: hidden;
    }
    summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      color: var(--muted);
      font-weight: 800;
      user-select: none;
    }
    summary::-webkit-details-marker { display: none; }

    .detailsBody {
      padding: 10px 12px 12px 12px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }

    .piece-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-width: 100px;
    }
    .piece-group strong { color: var(--text); margin-bottom: 5px; display:block; }
    .piece-group label { display: flex; align-items: center; gap: 8px; color: var(--muted); font-size: 0.9rem; cursor: pointer; }
    .piece-group input { cursor: pointer; }

    .streak-display {
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
        margin-bottom: 5px;
    }
    .streak-display strong { color: var(--text); }
    
    .hidden { display: none !important; }

    .marker-selected {
        fill: rgba(255, 255, 255, 0.4);
        stroke: none;
        pointer-events: none;
    }

    .marker-source {
        fill: rgba(20, 85, 30, 0.5); /* Greenish background */
        stroke: none;
        pointer-events: none;
    }

    .marker-dest {
        fill: rgba(20, 85, 30, 0.5);
        stroke: none;
        pointer-events: none;
    }

    /* Analysis Mode Markers (Flashy) */
    .marker-god-win { fill: #00ff00; opacity: 0.5; pointer-events: none; }
    .marker-god-draw { fill: #ffae00; opacity: 0.5; pointer-events: none; }
    .marker-god-loss { fill: #ff0000; opacity: 0.5; pointer-events: none; }

    /* Ensure markers are on top of pieces */
    #board svg .marker-dot {
        z-index: 10;
        pointer-events: none;
    }
    
    #board svg .marker-square {
        z-index: 1;
        pointer-events: none;
    }

    /* If cm-chessboard uses a specific layer structure, we might need to force the dot layer */
    #board .markers-layer.marker-dot {
        display: block;
    }
    
    /* --- Layout --- */

    /* Link lines to custom markers defined in HTML */
    .arrow-win line { 
        stroke: #4ade80 !important; 
        marker-end: url(#arrowHeadWin) !important;
    }
    .arrow-draw line { 
        stroke: #facc15 !important; 
        marker-end: url(#arrowHeadDraw) !important;
    }
    .arrow-loss line { 
        stroke: #f87171 !important; 
        marker-end: url(#arrowHeadLoss) !important;
    }

    /* Common visual finish */
    .arrow-win, .arrow-draw, .arrow-loss {
        opacity: 0.9;
        filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
    }
    
    /* Ensure the lines have round caps */
    .arrow-win line, .arrow-draw line, .arrow-loss line {
        stroke-linecap: round;
    }

    /* Remove old marker styling attempts */
    #board svg marker path,
    #board svg marker polygon {
        stroke-width: 0;
    }

    #godModeCheck:checked + span, /* If using a span wrapper (added below for safety) */
    #godModeCheck:checked ~ label, /* Or just targeting siblings if applicable */
    label:has(#godModeCheck:checked) {
        filter: drop-shadow(0 0 5px #00ff00);
    }
    
    #godModeContainer.active {
        background: rgba(46, 204, 113, 0.2) !important;
        border-color: rgba(46, 204, 113, 0.5) !important;
    }

    /* Fix mobile vertical jump by overriding body alignment at the end of cascade */
    @media (max-width: 900px) {
      body { place-items: start center; }
    }

  </style>
</head>

<body>
  <!-- Custom SVG Markers for Arrows -->
  <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" aria-hidden="true">
    <defs>
      <marker id="arrowHeadWin" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#4ade80" />
      </marker>
      <marker id="arrowHeadDraw" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#facc15" />
      </marker>
      <marker id="arrowHeadLoss" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#f87171" />
      </marker>
    </defs>
  </svg>

  <div class="app">
    <header>
      <h1>Trivial Endgames</h1>
    </header>

    <section class="layout">
      <div class="card boardCard">
        <div class="boardSizer">
          <div id="board" aria-label="Chessboard"></div>
        </div>
      </div>

      <div class="card sideCard">
        
        <div style="display:flex; justify-content:center; align-items:center; gap: 10px; padding: 4px 0;">
             <select id="endgameSelect" style="flex-grow:1; padding:10px; border-radius:14px; background:var(--btn); color:var(--text); border:1px solid var(--border); font-size:1.4rem; cursor:pointer;">
                 <option value="KP_K">â™šâ™Ÿ vs â™”</option>
                 <option value="K_KP">â™š vs â™”â™™</option>
                 <option value="KP_KR">â™šâ™Ÿ vs â™”â™–</option>
                 <option value="KR_KP">â™šâ™œ vs â™”â™™</option>
                 <option value="KRP_KR">â™šâ™œâ™Ÿ vs â™”â™–</option>
                 <option value="KR_KRP">â™šâ™œ vs â™”â™–â™™</option>
             </select>
             <div class="streak-card" style="white-space:nowrap; padding: 10px 14px; border-radius:14px; border:1px solid var(--border); background:rgba(255,255,255,0.02); font-size:14px; display:flex; align-items:center; justify-content:center;">
                Streak: <strong id="streak" style="margin-left:5px; font-size: 1.1rem;">0</strong>
             </div>
        </div>

        <div style="display:flex; gap:10px; align-items:stretch;">
            <div id="status" class="status" style="flex-grow:1;">Initializing...</div>
            
            <div id="godModeContainer" class="hidden" style="display:flex; align-items:center; background:rgba(255,255,255,0.05); padding:0 10px; border-radius:14px; border:1px solid var(--border);" title="Analysis Mode">
                <label style="cursor:pointer; font-size:1.2rem; margin:0; display:flex; align-items:center;">
                    <input type="checkbox" id="godModeCheck" style="display:none;"> ðŸ”Ž
                </label>
            </div>
            
            <button id="btnUndo" class="hidden" style="width: 50px; padding:0; font-size:1.5rem; border-radius:14px;" title="Undo last move">â†º</button>
        </div>

        <div class="btnRow" id="guessControls" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; align-items:center;">
          <button class="btn-win" id="btnWin">Win</button>
          <button class="btn-draw" id="btnDraw">Draw</button>
          <button class="btn-loss" id="btnLoss">Loss</button>
        </div>

        <button id="btnPlayAgain" class="hidden" style="background:var(--highlight-win); border:none; color:white;">Play Again &rarr;</button>

        <div class="btnRow2">
          <button id="btnNew">New Position</button>
          <a id="analyzeLink" class="linkBtn" href="#" target="_blank" rel="noopener noreferrer" aria-disabled="true">Analyze</a>
        </div>
      </div>
    </section>
  </div>

  <script type="module">
    // Debug helper
    window.onerror = function(msg, url, line, col, error) {
       document.getElementById("status").textContent = "JS Error: " + msg;
       document.getElementById("status").className = "status bad";
    };

    import { Chessboard, COLOR, BORDER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/Chessboard.js";
    import { Arrows, ARROW_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/extensions/arrows/Arrows.js";
    import { Markers, MARKER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/extensions/markers/Markers.js";
    import { Chess } from "https://cdn.jsdelivr.net/npm/chess.js@1.0.0-beta.7/+esm";

    // Custom Extension to render specific markers on top of pieces
    class ForegroundMarkers extends Markers {
        constructor(chessboard, props) {
            super(chessboard, props);
            // Move this extension's group to the end of the SVG (after pieces)
            // this.markerGroup is defined in the parent Markers class
            if (this.markerGroup && chessboard.view.svg) {
                chessboard.view.svg.appendChild(this.markerGroup);
            }
        }

        addMarker(type, square) {
            // Only handle destination dots and analysis mode markers
            if (type && (type.class === "marker-dest" || type.class.startsWith("marker-god"))) {
                super.addMarker(type, square);
            }
        }

        removeMarkers(type, square) {
            // Only handle destination dots and analysis mode markers
            if (!type || (type.class === "marker-dest" || type.class.startsWith("marker-god"))) {
                super.removeMarkers(type, square);
            }
        }
    }

    const MARKER_SELECTED = { class: "marker-selected", slice: "markerSquare" };
    const MARKER_SOURCE = { class: "marker-source", slice: "markerSquare" };
    const MARKER_DEST = { class: "marker-dest", slice: "markerDot" };
    
    const MARKER_GOD_WIN = { class: "marker-god-win", slice: "markerDot" };
    const MARKER_GOD_DRAW = { class: "marker-god-draw", slice: "markerDot" };
    const MARKER_GOD_LOSS = { class: "marker-god-loss", slice: "markerDot" };
    
    const ARROW_WIN = { ...ARROW_TYPE.default, class: "arrow-win" };
    const ARROW_DRAW = { ...ARROW_TYPE.default, class: "arrow-draw" };
    const ARROW_LOSS = { ...ARROW_TYPE.default, class: "arrow-loss" };

    const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-";
    const PIECE_ORDER = "KQRBNP";

    console.log("Imports loaded");
    document.getElementById("status").textContent = "Imports loaded...";
    
    const TABLEBASE_URL = "https://tablebase.lichess.ovh/standard?fen=";

    // --- DOM Elements ---
    const el = {
      status: document.getElementById("status"),
      streak: document.getElementById("streak"),
      btnWin: document.getElementById("btnWin"),
      btnDraw: document.getElementById("btnDraw"),
      btnLoss: document.getElementById("btnLoss"),
      btnNew: document.getElementById("btnNew"),
      btnPlayAgain: document.getElementById("btnPlayAgain"),
      analyze: document.getElementById("analyzeLink"),
      guessControls: document.getElementById("guessControls"),
      btnUndo: document.getElementById("btnUndo"),
      godModeContainer: document.getElementById("godModeContainer"),
      godModeCheck: document.getElementById("godModeCheck"),
    };

    // --- State ---
    let chess = new Chess();
    let board = null;
    let currentFen = "";
    let initialFen = "";
    let currentTbData = null;
    let streak = 0;
    let isUserTurn = false;
    let gameActive = false;
    let currentObjective = null;
    let selectedSquare = null;
    let cachedPositions = null;
    let cachedFilename = null;
    let godMode = false;
    let analysisMode = false;

    // --- Init Board ---
    board = new Chessboard(document.getElementById("board"), {
      assetsUrl: "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/",
      position: "8/8/8/8/8/8/8/8", // "empty" keyword crashes, use explicit FEN
      orientation: COLOR.white,
      style: {
        pieces: { file: "pieces/standard.svg" },
        borderType: BORDER_TYPE.none
      },
      extensions: [{ class: Arrows }, { class: Markers }, { class: ForegroundMarkers }]
    });

    board.enableMoveInput((event) => {
        if (!isUserTurn || !gameActive) return false;

        switch (event.type) {
            case "moveInputStarted":
                const p = chess.get(event.square);
                // In Analysis Mode, allow picking up any piece relative to turn
                const isTurnColor = p && p.color === chess.turn();
                const isOurPiece = p && p.color === 'w';
                
                if (godMode || analysisMode ? isTurnColor : isOurPiece) {
                    if (selectedSquare === event.square) {
                        selectSquare(null);
                        return false; // Stop interaction on deselect
                    } else {
                        selectSquare(event.square);
                        return true;
                    }
                }
                return false;
                
            case "validateMoveInput":
                try {
                    const temp = new Chess(chess.fen());
                    const m = temp.move({ from: event.squareFrom, to: event.squareTo, promotion: 'q' });
                    return !!m;
                } catch (e) { return false; }
                
            case "moveInputFinished":
                // Defer clearing to ensure it happens after any internal event handling
                setTimeout(() => selectSquare(null), 10);
                if (event.legalMove) {
                    handleUserMove(event.squareFrom, event.squareTo);
                }
                return true;
        }
    });

    // --- Event Listeners ---
    el.btnWin.addEventListener("click", () => handleGuess(2)); // Win for White
    el.btnDraw.addEventListener("click", () => handleGuess(0));
    el.btnLoss.addEventListener("click", () => handleGuess(-2));
    
    el.btnNew.addEventListener("click", startNewGame);
    el.btnPlayAgain.addEventListener("click", startNewGame);
    el.btnUndo.addEventListener("click", undoLastMove);
    
    if (el.godModeCheck) {
        el.godModeCheck.addEventListener("change", (e) => {
            godMode = e.target.checked;
            if (godMode) el.godModeContainer.classList.add("active");
            else el.godModeContainer.classList.remove("active");
            
            // Clear selection/markers on toggle to prevent stale state
            selectSquare(null);
            clearArrows();

            if (godMode) {
                 gameActive = true; // Ensure movement is allowed
                 analysisMode = false;
                 setStatus(null, "Analysis Mode Active.");
                 setGuessEnabled(false);
                 el.guessControls.classList.add("hidden");
            } else {
                 // Deactivated: Still allow movement (Sandbox mode)
                 gameActive = true; 
                 analysisMode = true;
                 setStatus(null, "Analysis Mode (Sandbox).");
            }
        });
    }

    async function undoLastMove() {
        // Allow undo even if gameActive is false (e.g. after blunder endGame)
        
        // If it's black's turn (user just played and blundered), undo 1 move.
        // If it's white's turn (normal flow), undo 2 moves.
        
        if (chess.turn() === 'b') {
             chess.undo();
        } else {
             chess.undo();
             chess.undo();
        }

        currentFen = chess.fen();
        await board.setPosition(currentFen, true);
        
        // Refresh TB Data
        try {
            currentTbData = await fetchTablebase(currentFen);
            
            // Re-evaluate state
            gameActive = true; // Reactivate game
            isUserTurn = true;
            setStatus(null, "Your Turn");
            clearArrows();
            
            if (chess.history().length === 0) {
                 el.btnUndo.classList.add("hidden");
            }
        } catch(e) { console.error(e); }
    }

    function selectSquare(sq) {
        clearArrows(); // Clear arrows on selection
        board.removeMarkers(MARKER_SOURCE);
        board.removeMarkers(MARKER_DEST);
        board.removeMarkers(MARKER_SELECTED); // Cleanup old
        board.removeMarkers(MARKER_GOD_WIN);
        board.removeMarkers(MARKER_GOD_DRAW);
        board.removeMarkers(MARKER_GOD_LOSS);
        
        selectedSquare = sq;
        if (selectedSquare) {
            // Add Source Marker
            board.addMarker(MARKER_SOURCE, selectedSquare);
            
            if (godMode && currentTbData && currentTbData.moves) {
                // Analysis Mode: Use TB data to color destinations
                // Filter moves starting from selectedSquare
                const moves = currentTbData.moves.filter(m => m.uci.startsWith(selectedSquare));
                
                // Aggregate by destination to handle promotions (pick best outcome)
                const destMap = new Map();
                
                moves.forEach(m => {
                    const dest = m.uci.slice(2, 4);
                    const wdl = categoryToWdl(m.category); // 2, 0, -2
                    
                    // Logic: -2 (Green/Win) > 0 (Orange/Draw) > 2 (Red/Loss)
                    if (!destMap.has(dest)) {
                        destMap.set(dest, wdl);
                    } else {
                        const currentBest = destMap.get(dest);
                        // We want the MIN value (most negative is best for us)
                        if (wdl < currentBest) {
                            destMap.set(dest, wdl);
                        }
                    }
                });
                
                destMap.forEach((wdl, dest) => {
                    let marker = MARKER_GOD_DRAW;
                    if (wdl === 2) marker = MARKER_GOD_LOSS;   // Opponent Wins -> We Lose -> Red
                    else if (wdl === -2) marker = MARKER_GOD_WIN; // Opponent Loses -> We Win -> Green
                    
                    board.addMarker(marker, dest);
                });
                
            } else {
                // Standard Mode: Just show valid destinations
                const moves = chess.moves({ square: selectedSquare, verbose: true });
                moves.forEach(m => {
                    board.addMarker(MARKER_DEST, m.to);
                });
            }
        }
    }

    // --- Persistence ---
    function saveSettings() {
        try {
            const sel = document.getElementById("endgameSelect");
            const val = sel.value;
            localStorage.setItem("endgame-trainer-selection", val);
        } catch(e) { console.warn("Could not save settings", e); }
    }

    function loadSettings() {
        try {
            const val = localStorage.getItem("endgame-trainer-selection");
            if (val) {
                const sel = document.getElementById("endgameSelect");
                if (sel) {
                    sel.value = val;
                }
            }
        } catch(e) { console.warn("Could not load settings", e); }
    }
    
    // Init Persistence
    loadSettings();
    const sel = document.getElementById('endgameSelect');
    if(sel) sel.addEventListener('change', () => {
        saveSettings();
        startNewGame();
    });

    // Start
    console.log("Starting game loop...");
    startNewGame();


    // --- Core Logic ---

    async function startNewGame() {
        console.log("startNewGame called");
        gameActive = false;
        isUserTurn = false;
        currentTbData = null;
        clearArrows();
        selectSquare(null);
        setGuessEnabled(false);
        if(el.btnPlayAgain) el.btnPlayAgain.classList.add("hidden");
        el.btnWin.classList.remove("hidden");
        el.btnDraw.classList.remove("hidden");
        el.btnLoss.classList.remove("hidden");
        if(el.guessControls) el.guessControls.classList.remove("hidden");
        if(el.btnUndo) el.btnUndo.classList.add("hidden");
        if(el.godModeContainer) {
            el.godModeContainer.classList.add("hidden");
            el.godModeContainer.classList.remove("active");
        }
        if(el.godModeCheck) { el.godModeCheck.checked = false; godMode = false; }
        analysisMode = false;
        setStatus("warn", "Generating position...");
        
        try {
            console.log("Generating valid position...");
            const fen = await generateValidPosition();
            console.log("Position generated:", fen);
            
            currentFen = fen;
            initialFen = fen;
            console.log("Loading into Chess.js...");
            try {
                chess.load(fen);
            } catch(loadErr) {
                throw new Error("Chess.load failed on FEN: " + fen + " :: " + loadErr);
            }
            
            console.log("Setting board position...");
            await board.setPosition(fen, true);
            
            // Get initial TB data
            console.log("Fetching TB data...");
            currentTbData = await fetchTablebase(fen);
            console.log("TB Data received", currentTbData);
            
            // Set Objective
            // normalize wdl from category if needed handled in fetchTablebase
            
            updateLinks(initialFen);
            setStatus(null, "Your Turn: Guess result or Play a move.");
            setGuessEnabled(true);
            gameActive = true;
            isUserTurn = true;

        } catch (e) {
            console.error(e);
            setStatus("bad", "Error: " + e.message);
        }
    }

    async function handleUserMove(from, to) {
        clearArrows();
        // Double check: clear any selection immediately
        selectSquare(null);

        if (!gameActive) return;

        // Move is valid (already checked by cm-chessboard)
        chess.move({ from, to, promotion: 'q' });
        
        // Analysis Mode / Sandbox Bypass
        if (godMode || analysisMode) {
             currentFen = chess.fen();
             await board.setPosition(currentFen, true); // Ensure board sync
             
             // Update Undo visibility
             if (el.btnUndo && chess.history().length > 0) el.btnUndo.classList.remove("hidden");

             try {
                currentTbData = await fetchTablebase(currentFen);
                const turnStr = chess.turn() === 'w' ? "White" : "Black";
                
                if (godMode) {
                    setStatus(null, `Analysis Mode: ${turnStr} to move.`);
                } else {
                    setStatus(null, `Analysis: ${turnStr} to move.`);
                }
                
                if (chess.isGameOver()) {
                    let msg = "Game Over.";
                    if (chess.isCheckmate()) msg = "Checkmate!";
                    if (chess.isStalemate()) msg = "Stalemate!";
                    setStatus("ok", msg);
                }
             } catch(e) { console.error(e); }
             return;
        }

        isUserTurn = false;
        setStatus("warn", "Thinking...");

        // Evaluate Move
        const prevWdl = currentTbData.wdl;
        
        // Fetch new data
        try {
            const newFen = chess.fen();
            console.log("Fetching response for FEN:", newFen);
            const newData = await fetchTablebase(newFen);
            console.log("Response received:", newData);
            
            // Check blunder
            // White moved. Now Black to move.
            // If White was Winning (2), Black should be Losing (-2).
            // If White was Drawing (0), Black should be Drawing (0).
            
            let failed = false;
            let msg = "";

            if (prevWdl === 2) { // We were winning
                 if (newData.wdl !== -2) { // Opponent not losing
                     failed = true;
                     msg = "Blunder! You turned a Win into a Draw/Loss.";
                 }
            } else if (prevWdl === 0) { // Drawing
                 if (newData.wdl === 2) { // Opponent Winning
                     failed = true;
                     msg = "Blunder! You turned a Draw into a Loss.";
                 }
            }
            
            if (failed) {
                endGame(false, msg);
                if (el.btnUndo) el.btnUndo.classList.remove("hidden");
                // Revert board to show? No, keep it.
                return;
            }

            if (chess.isGameOver()) {
                handleGameOver();
                return;
            }

            // Computer Reply (Best Move)
            if (newData.moves && newData.moves.length > 0) {
                let bestMove = newData.moves[0];
                console.log("Computer best move (default):", bestMove.uci);

                // Tie-break for Draw: Prefer no capture
                const bestWdl = categoryToWdl(bestMove.category);
                if (bestWdl === 0) { // If best outcome is Draw
                    // Filter moves that preserve the Draw
                    const drawMoves = newData.moves.filter(m => categoryToWdl(m.category) === 0);
                    
                    // Look for non-capture among draw moves
                    // Using SAN to detect capture ('x')
                    const nonCapture = drawMoves.find(m => m.san && !m.san.includes('x'));
                    
                    if (nonCapture) {
                        console.log("Switched to non-capture draw move:", nonCapture.uci);
                        bestMove = nonCapture;
                    }
                }

                const uci = bestMove.uci;
                const fromC = uci.slice(0, 2);
                const toC = uci.slice(2, 4);
                
                chess.move({ from: fromC, to: toC, promotion: 'q' });
                await board.setPosition(chess.fen(), true);
                
                if (chess.isGameOver()) {
                    handleGameOver();
                    return;
                }
                
                // Update state
                currentFen = chess.fen();
                currentTbData = await fetchTablebase(currentFen);
                
                isUserTurn = true;
                setStatus(null, "Your Turn");
                if (el.btnUndo && chess.history().length > 0) {
                    el.btnUndo.classList.remove("hidden");
                }
                // updateLinks removed
            } else {
                handleGameOver();
            }

        } catch (e) {
            setStatus("bad", "Error: " + e.message);
        }
    }

    function handleGuess(guessWdl) {
        if (!gameActive) return;
        drawOutcomeArrows(currentTbData);
        
        const actualWdl = currentTbData.wdl;
        
        let correct = (guessWdl === actualWdl);
        
        if (correct) {
            streak++;
            updateStreak();
            setStatus("ok", `Correct! It is a ${wdlToString(actualWdl)}.`);
        } else {
            streak = 0;
            updateStreak();
            setStatus("bad", `Wrong. It is a ${wdlToString(actualWdl)}.`);
        }
        setGuessEnabled(false);
        // Hide only guess buttons, show Analysis Mode toggle
        el.btnWin.classList.add("hidden");
        el.btnDraw.classList.add("hidden");
        el.btnLoss.classList.add("hidden");
        if (el.godModeContainer) el.godModeContainer.classList.remove("hidden");
    }

    function handleGameOver() {
        let success = false;
        let msg = "";

        if (chess.isCheckmate()) {
            if (chess.turn() === 'b') { // White moved last => White mated Black
                success = true;
                msg = "Checkmate! You Won!";
            } else {
                // Black mated White
                // Only success if objective was Loss (unlikely)
                success = (currentTbData.wdl === -2);
                msg = success ? "Checkmate (Expected Loss)" : "Checkmate! You Lost.";
            }
        } else if (chess.isStalemate()) {
            // Stalemate is a Draw.
            // Success if objective was Draw (0) or Loss (-2 - saving a loss is good?). 
            // Usually if WDL=0, Stalemate is success.
            success = (currentTbData.wdl <= 0);
            msg = "Stalemate!";
        } else {
            // Insufficient material, 50-move, etc. => Draw
            success = (currentTbData.wdl <= 0);
            msg = "Game Over (Draw).";
        }

        if (success) {
            streak++;
            updateStreak();
            setStatus("ok", msg); // Green
        } else {
            // Reset streak on failure
            streak = 0;
            updateStreak();
            setStatus("bad", msg); // Red
        }
        
        endGame(success, msg);
    }

    function endGame(success, msg) {
        gameActive = false;
        isUserTurn = false;
        setStatus(success ? "ok" : "bad", msg);
        setGuessEnabled(false);
        
        el.btnWin.classList.add("hidden");
        el.btnDraw.classList.add("hidden");
        el.btnLoss.classList.add("hidden");
        
        if (!success) {
            streak = 0;
            updateStreak();
        }
        if (el.godModeContainer) el.godModeContainer.classList.remove("hidden");
    }

    // --- Generation & Validation Logic ---

    async function generateValidPosition() {
        // 1. Determine Piece Composition from UI
        let { w, b } = getSelectedPieces();
        
        // Ensure Kings
        if(!w.includes('K')) w.push('K');
        if(!b.includes('K')) b.push('K');

        // 2. Sort Pieces to match file format (K, Q, R, B, N, P)
        const sortOrder = (p) => PIECE_ORDER.indexOf(p);
        w.sort((a, b) => sortOrder(a) - sortOrder(b));
        b.sort((a, b) => sortOrder(a) - sortOrder(b));

        // 3. Construct File Path
        const filename = `${w.join('')}_${b.join('')}.txt`;
        const url = `out/${filename}`; // Relative path

        let text = "";

        // Check Cache
        if (cachedFilename === filename && cachedPositions) {
            console.log(`Using cached positions for: ${filename}`);
            text = cachedPositions;
        } else {
            console.log(`Cache miss. Fetching positions from: ${url}`);
            setStatus("warn", "Fetching position...");

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`No positions found for material: ${w.join('')} vs ${b.join('')}. (File ${filename} missing)`);
                    }
                    throw new Error(`Network error: ${response.status} ${response.statusText}`);
                }

                text = await response.text();
                if (!text) throw new Error("Position file is empty.");
                
                // Update Cache
                cachedPositions = text;
                cachedFilename = filename;

            } catch (e) {
                console.error(e);
                throw new Error(e.message);
            }
        }

        // 4. Calculate Record Details
        const flatList = [
            ...w.map(p => ({ type: p, color: 'w' })),
            ...b.map(p => ({ type: p, color: 'b' }))
        ];
        const recordLength = flatList.length;

        if (text.length % recordLength !== 0) {
            console.warn(`File length (${text.length}) is not a multiple of record length (${recordLength}). Trimming end.`);
        }

        const totalRecords = Math.floor(text.length / recordLength);
        if (totalRecords === 0) throw new Error("File contains no complete records.");

        // 5. Pick Random Record
        const randomIndex = Math.floor(Math.random() * totalRecords);
        const startOffset = randomIndex * recordLength;
        const record = text.substring(startOffset, startOffset + recordLength);

        console.log(`Selected record #${randomIndex}: ${record}`);

        // 6. Decode Record to Board/FEN
        // ALPHABET index -> 0..63.
        // 0 = a1, 1 = b1 ... 7 = h1, 8 = a2 ...
        
        const grid = Array(8).fill(null).map(() => Array(8).fill(""));

        for (let i = 0; i < recordLength; i++) {
            const char = record[i];
            const val = ALPHABET.indexOf(char);
            if (val === -1) throw new Error(`Invalid character '${char}' in record.`);

            const file = val % 8;       // 0-7 (a-h)
            const rank = Math.floor(val / 8); // 0-7 (1-8)

            // Grid usually indexed [row][col] where row 0 is top (rank 8)
            // row index = 7 - rank
            const gridRow = 7 - rank;
            const gridCol = file;

            const pieceDef = flatList[i];
            const pChar = pieceDef.type.toUpperCase();
            grid[gridRow][gridCol] = (pieceDef.color === 'w' ? pChar : pChar.toLowerCase());
        }

        // 7. Build FEN String
        let fenRows = grid.map(row => {
            let empty = 0;
            let str = "";
            row.forEach(c => {
                if (c === "") empty++;
                else {
                    if (empty > 0) str += empty;
                    empty = 0;
                    str += c;
                }
            });
            if (empty > 0) str += empty;
            return str;
        });
        
        const fen = fenRows.join("/") + " w - - 0 1";
        return fen;
    }

    // --- Helpers ---

    function clearArrows() {
        if (typeof board.removeArrows === "function") board.removeArrows();
    }

    function uciToArrow(uci) {
        if (typeof uci !== "string" || uci.length < 4) return null;
        const from = uci.slice(0, 2);
        const to = uci.slice(2, 4);
        if (!/^[a-h][1-8]$/.test(from) || !/^[a-h][1-8]$/.test(to)) return null;
        return { from, to };
    }

    function categoryToWdl(category) {
        const c = String(category || "").toLowerCase();
        if (c.includes("win")) return 2;
        if (c.includes("loss")) return -2;
        if (c.includes("draw")) return 0;
        return null;
    }

    function drawOutcomeArrows(tbData) {
        clearArrows();
        const moves = Array.isArray(tbData?.moves) ? tbData.moves : [];
        if (!moves.length) return;

        for (const m of moves) {
            const arrow = uciToArrow(m.uci);
            if (!arrow) continue;
            
            const baseWdl = categoryToWdl(m.category); // Raw WDL from category
            if (baseWdl === null) continue;

            // Invert the WDL to match user's observed colors (winning moves appearing red, losing moves appearing green).
            const moveWdl = -baseWdl; 

            let arrowType = null;
            if (moveWdl === 2) arrowType = ARROW_WIN;
            else if (moveWdl === 0) arrowType = ARROW_DRAW;
            else if (moveWdl === -2) arrowType = ARROW_LOSS;

            if (arrowType) {
                board.addArrow(arrowType, arrow.from, arrow.to);
            }
        }
    }

    function getSelectedPieces() {
        const val = document.getElementById("endgameSelect").value;
        const [whitePart, blackPart] = val.split('_');
        const w = whitePart.split(''); // e.g. "KP" -> ['K', 'P']
        const b = blackPart.split(''); // e.g. "KR" -> ['K', 'R']
        return { w, b };
    }

    async function fetchTablebase(fen) {
        const url = TABLEBASE_URL + encodeURIComponent(fen);
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        
        // Normalize
        if (typeof data.wdl === 'undefined' && data.category) {
            const cat = data.category;
            if (cat === 'win') data.wdl = 2;
            else if (cat === 'loss') data.wdl = -2;
            else if (cat === 'draw') data.wdl = 0;
            else data.wdl = 0;
        }
        return data;
    }

    function setStatus(kind, text) {
        el.status.textContent = text;
        el.status.className = "status " + (kind || "");
    }

    function setGuessEnabled(en) {
        el.btnWin.disabled = !en;
        el.btnDraw.disabled = !en;
        el.btnLoss.disabled = !en;
    }

    function updateStreak() {
        el.streak.textContent = streak;
    }

    function wdlToString(wdl) {
        if (wdl > 0) return "Win";
        if (wdl < 0) return "Loss";
        return "Draw";
    }
    
    function updateLinks(fen) {
        el.analyze.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
        el.analyze.removeAttribute("aria-disabled");
    }

  </script>
</body>
</html>
