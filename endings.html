<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trivial Endgames</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/assets/chessboard.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/assets/extensions/arrows/arrows.css">

  <style>
    :root {
      --bg: #0b0f17;
      --panel: #111828;
      --panel2: #0f1624;
      --text: #e7eefc;
      --muted: #a9b6cf;
      --border: rgba(231, 238, 252, 0.12);
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --btn: #1c2a44;
      --btnHover: #243659;
      
      /* Spec Palette */
      --color-analysis: #6FB4FF;
      --color-win: #1F6F4A;
      --color-draw: #FF8C00;
      --color-loss: #6E2B36;
      --color-neutral-icon: rgba(255,255,255,0.55);

      --pagePad: 24px;
      --cardPad: 16px;
      --gap: 18px;
      --boardSize: min(600px, 65vh);
    }

    @media (max-width: 900px) {
      :root { --gap: 14px; --boardSize: min(580px, 60vh); }
      body { place-items: start center; }
    }

    @media (max-width: 600px) {
      :root {
        --pagePad: 10px;
        --cardPad: 10px;
        --gap: 10px;
        --boardSize: min(96vw, 46svh, 500px);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 50% 0%, #162445 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100svh;
      padding: var(--pagePad);
      display: grid;
      place-items: center;
    }

    .app {
      width: min(1000px, 100%);
      display: grid;
      gap: var(--gap);
    }

    header {
      display: flex;
      gap: 12px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: var(--gap);
      align-items: start;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .boardCard {
      padding: 0; /* Removed padding for full-bleed board */
      display: grid;
      place-items: center;
      border: none; /* Optional: remove card border if desired, but padding=0 usually fixes the 'frame' look */
      background: transparent; /* Remove card background so only board shows */
      box-shadow: none;
    }

    /* Force hide cm-chessboard border if JS setting fails */
    .cm-chessboard .border { 
        display: none !important; 
        stroke: none !important;
    }

    /* Promotion Dialog visibility fix */
    .cm-chessboard-promotion-dialog {
        background: white !important;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    
    /* Target SVG background rect if present */
    .promotion-dialog-group rect, 
    .cm-chessboard-content .promotion-dialog-group rect {
        fill: white !important;
        stroke: #999 !important;
    }
    
    /* Ensure context menu style dialogs are also white */
    div[class*="promotion-dialog"] {
        background-color: white !important;
    }

    .cm-chessboard-promotion-dialog .promotion-piece {
        cursor: pointer;
    }

    .boardSizer {
      width: min(100%, var(--boardSize));
      height: min(100%, var(--boardSize));
      overflow: visible;
    }

    #board {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden;
    }

    .sideCard {
      padding: var(--cardPad);
      display: grid;
      gap: 10px;
    }

    .status {
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
      color: var(--muted);
      font-size: 14px;
      line-height: 1.35;
      white-space: pre-wrap;
      text-align: center;
      min-height: 3em;
      display: flex; align-items: center; justify-content: center;
    }
    .status.ok   { border-color: rgba(46, 204, 113, 0.35); color: rgba(46, 204, 113, 0.95); }
    .status.bad  { border-color: rgba(255, 92, 92, 0.35); color: rgba(255, 92, 92, 0.95); }
    .status.warn { border-color: rgba(255, 204, 102, 0.35); color: rgba(255, 204, 102, 0.95); }

    .btnRow {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .btnRow2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button, a.linkBtn {
      appearance: none;
      border: none; /* Removed border */
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 750;
      letter-spacing: 0.2px;
      transition: transform 0.04s ease, background 0.15s ease, opacity 0.15s ease;
      text-align: center;
      text-decoration: none;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      min-height: 44px;
      font-size: 0.95rem;
    }
    button:hover, a.linkBtn:hover { background: var(--btnHover); }
    button:active, a.linkBtn:active { transform: translateY(1px); }
    button:disabled, a.linkBtn[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .btn-win { background: rgba(46, 204, 113, 0.2) !important; }
    .btn-draw { background: rgba(255, 204, 102, 0.2) !important; }
    .btn-loss { background: rgba(255, 92, 92, 0.2) !important; }
    
    .btn-win:hover { background: rgba(46, 204, 113, 0.3) !important; }
    .btn-draw:hover { background: rgba(255, 204, 102, 0.3) !important; }
    .btn-loss:hover { background: rgba(255, 92, 92, 0.3) !important; }

    details {
      border: none; /* Removed border */
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
      overflow: hidden;
    }
    summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      color: var(--muted);
      font-weight: 800;
      user-select: none;
    }
    summary::-webkit-details-marker { display: none; }

    .detailsBody {
      padding: 10px 12px 12px 12px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }

    .piece-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-width: 100px;
    }
    .piece-group strong { color: var(--text); margin-bottom: 5px; display:block; }
    .piece-group label { display: flex; align-items: center; gap: 8px; color: var(--muted); font-size: 0.9rem; cursor: pointer; }
    .piece-group input { cursor: pointer; }

    .streak-display {
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
        margin-bottom: 5px;
    }
    .streak-display strong { color: var(--text); }
    
    .hidden { display: none !important; }

    .marker-selected {
        fill: rgba(255, 255, 255, 0.4);
        stroke: none;
        pointer-events: none;
    }

    .marker-source {
        fill: rgba(20, 85, 30, 0.5) !important; /* Lichess-style greenish background - increased opacity */
        stroke: none;
        pointer-events: none;
    }

    .marker-dest {
        fill: rgba(20, 85, 30, 0.5);
        stroke: none;
        pointer-events: none;
    }

    /* Analysis Mode Markers (Flashy) */
    .marker-god-win { fill: #00ff00; opacity: 0.6; pointer-events: none; }
    .marker-god-draw { fill: #FF8C00; opacity: 0.6; pointer-events: none; }
    .marker-god-loss { fill: #ff0000; opacity: 0.6; pointer-events: none; }

    /* Ensure markers are on top of pieces */
    #board svg .marker-dot {
        z-index: 10;
        pointer-events: none;
    }
    
    #board svg .marker-square {
        z-index: 1;
        pointer-events: none;
    }

    /* If cm-chessboard uses a specific layer structure, we might need to force the dot layer */
    #board .markers-layer.marker-dot {
        display: block;
    }
    
    /* --- Layout --- */

    /* Link lines to custom markers defined in HTML */
    /* Target the group and all children to force stroke */
    .arrow-win, .arrow-win * { 
        stroke: var(--color-win) !important; 
        stroke-width: 4px !important;
        fill: none !important;
    }
    .arrow-win line, .arrow-win path {
        marker-end: url(#arrowHeadWin) !important;
    }

    .arrow-draw, .arrow-draw * { 
        stroke: var(--color-draw) !important; 
        stroke-width: 4px !important;
        fill: none !important;
    }
    .arrow-draw line, .arrow-draw path {
        marker-end: url(#arrowHeadDraw) !important;
    }

    .arrow-loss, .arrow-loss * { 
        stroke: var(--color-loss) !important; 
        stroke-width: 4px !important;
        fill: none !important;
    }
    .arrow-loss line, .arrow-loss path {
        marker-end: url(#arrowHeadLoss) !important;
    }

    /* Common visual finish */
    .arrow-win, .arrow-draw, .arrow-loss {
        opacity: 0.9;
        filter: drop-shadow(0 0 4px rgba(0,0,0,0.5));
    }
    
    /* Ensure the lines have round caps */
    .arrow-win line, .arrow-draw line, .arrow-loss line {
        stroke-linecap: round;
    }

    /* Remove old marker styling attempts */
    #board svg marker path,
    #board svg marker polygon {
        stroke-width: 0;
    }

    /* Analysis Mode Toggle styling */
    #godModeBtn {
        /* Matches standard button style (linkBtn) */
        color: var(--color-analysis); /* Always use the Analysis/Tool color */
        font-size: 1.2rem;
    }

    /* Fix mobile vertical jump by overriding body alignment at the end of cascade */
    @media (max-width: 900px) {
      body { place-items: start center; }
    }

  </style>
</head>

<body>
  <!-- Custom SVG Markers for Arrows -->
  <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" aria-hidden="true">
    <defs>
      <marker id="arrowHeadWin" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-win)" />
      </marker>
      <marker id="arrowHeadDraw" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-draw)" />
      </marker>
      <marker id="arrowHeadLoss" viewBox="0 0 10 10" refX="2.5" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--color-loss)" />
      </marker>
    </defs>
  </svg>

  <div class="app">
    <header>
      <h1>Trivial Endgames</h1>
    </header>

    <section class="layout">
      <div class="card boardCard">
        <div class="boardSizer">
          <div id="board" aria-label="Chessboard"></div>
        </div>
      </div>

      <div class="sideCard">
        
        <div style="display:flex; justify-content:center; align-items:center; gap: 10px; padding: 4px 0;">
             <select id="endgameSelect" style="flex-grow:1; padding:10px; border-radius:14px; background:var(--btn); color:var(--text); border:1px solid var(--border); font-size:1.4rem; cursor:pointer;">
                 <option value="KP_K">‚ôö‚ôü vs ‚ôî</option>
                 <option value="K_KP">‚ôö vs ‚ôî‚ôô</option>
                 <option value="KP_KR">‚ôö‚ôü vs ‚ôî‚ôñ</option>
                 <option value="KR_KP">‚ôö‚ôú vs ‚ôî‚ôô</option>
                 <option value="KRP_KR">‚ôö‚ôú‚ôü vs ‚ôî‚ôñ</option>
                 <option value="KR_KRP">‚ôö‚ôú vs ‚ôî‚ôñ‚ôô</option>
                 <option value="KBP_KB">‚ôö‚ôù‚ôü vs ‚ôî‚ôó</option>
             </select>
             <div class="streak-card" style="white-space:nowrap; padding: 10px 14px; border-radius:14px; border:none; background:rgba(255,255,255,0.02); font-size:14px; display:flex; align-items:center; justify-content:center;">
                Streak: <strong id="streak" style="margin-left:5px; font-size: 1.1rem;">0</strong>
             </div>
        </div>

        <div style="display:flex; gap:10px; align-items:stretch;">
            <div id="status" class="status" style="flex-grow:1;">Initializing...</div>
            
            <button id="btnUndo" class="hidden" style="width: 50px; padding:0; font-size:1.5rem; border-radius:14px;" title="Undo last move">‚Ü∫</button>
        </div>

        <div class="btnRow" id="guessControls" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; align-items:center;">
          <button class="btn-win" id="btnWin">Win</button>
          <button class="btn-draw" id="btnDraw">Draw</button>
          <button class="btn-loss" id="btnLoss">Loss</button>
        </div>

        <button id="btnPlayAgain" class="hidden" style="background:var(--highlight-win); border:none; color:white;">Play Again &rarr;</button>

        <div class="btnRow2" style="align-items:center;">
          <button id="btnNew">New Position</button>
          
          <div style="display:flex; gap:10px; align-items:center; width:100%;">
              <button id="godModeBtn" class="linkBtn" style="flex:1 1 0;" title="Analysis Mode">
                üîé
              </button>
              
              <a id="analyzeLink" class="linkBtn" href="#" target="_blank" rel="noopener noreferrer" aria-disabled="true" title="Analyze on Lichess" style="flex:1 1 0;">
                <!-- Local Lichess Logo -->
                <img src="Lichess-White-Logo-Online-Chess-49.png" alt="Lichess" height="28" style="object-fit: contain;">
              </a>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script type="module">
    // Debug helper
    window.onerror = function(msg, url, line, col, error) {
       document.getElementById("status").textContent = "JS Error: " + msg;
       document.getElementById("status").className = "status bad";
    };

    import { Chessboard, COLOR, BORDER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/Chessboard.js";
    import { Arrows, ARROW_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/extensions/arrows/Arrows.js";
    import { Markers, MARKER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/extensions/markers/Markers.js";
    import { PromotionDialog } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/src/extensions/promotion-dialog/PromotionDialog.js";
    import { Chess } from "https://cdn.jsdelivr.net/npm/chess.js@1.0.0-beta.7/+esm";

    // Custom Extension to render ALL markers on top of pieces
    class CustomMarkers extends Markers {
        constructor(chessboard, props) {
            super(chessboard, props);
            
            // Create a new SVG layer on top of everything
            this.topSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.topSvg.style.position = "absolute";
            this.topSvg.style.top = "0";
            this.topSvg.style.left = "0";
            this.topSvg.style.width = "100%";
            this.topSvg.style.height = "100%";
            this.topSvg.style.pointerEvents = "none";
            this.topSvg.style.zIndex = "100";
            
            // Append to the chessboard container
            // chessboard.element is usually the container div
            if (chessboard.element) {
                chessboard.element.appendChild(this.topSvg);
            } else if (chessboard.view && chessboard.view.element) {
                chessboard.view.element.appendChild(this.topSvg);
            }

            // Sync viewBox and move markers
            this.syncOverlay();
            
            // Keep syncing in case of resize/init delays
            this.observer = new MutationObserver(() => this.syncOverlay());
            if (chessboard.view.svg) {
                this.observer.observe(chessboard.view.svg, { attributes: true, attributeFilter: ['viewBox'] });
            }
        }

        syncOverlay() {
            const mainSvg = this.chessboard.view.svg;
            if (mainSvg && this.topSvg) {
                // Sync viewBox
                const viewBox = mainSvg.getAttribute("viewBox");
                if (viewBox) this.topSvg.setAttribute("viewBox", viewBox);
                
                // Move markerGroup to top layer
                if (this.markerGroup && this.markerGroup.parentNode !== this.topSvg) {
                    this.topSvg.appendChild(this.markerGroup);
                }
            }
        }
        
        // No override for add/remove needed, they operate on markerGroup
    }

    const MARKER_SELECTED = { class: "marker-selected", slice: "markerSquare" };
    const MARKER_SOURCE = { class: "marker-source", slice: "markerSquare" };
    const MARKER_DEST = { class: "marker-dest", slice: "markerDot" };
    
    const MARKER_GOD_WIN = { class: "marker-god-win", slice: "markerDot" };
    const MARKER_GOD_DRAW = { class: "marker-god-draw", slice: "markerDot" };
    const MARKER_GOD_LOSS = { class: "marker-god-loss", slice: "markerDot" };
    
    const ARROW_WIN = { ...ARROW_TYPE.default, class: "arrow-win" };
    const ARROW_DRAW = { ...ARROW_TYPE.default, class: "arrow-draw" };
    const ARROW_LOSS = { ...ARROW_TYPE.default, class: "arrow-loss" };

    const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-";
    const PIECE_ORDER = "KQRBNP";

    console.log("Imports loaded");
    document.getElementById("status").textContent = "Imports loaded...";
    
    const TABLEBASE_URL = "https://tablebase.lichess.ovh/standard?fen=";

    // --- DOM Elements ---
    const el = {
      status: document.getElementById("status"),
      streak: document.getElementById("streak"),
      btnWin: document.getElementById("btnWin"),
      btnDraw: document.getElementById("btnDraw"),
      btnLoss: document.getElementById("btnLoss"),
      btnNew: document.getElementById("btnNew"),
      btnPlayAgain: document.getElementById("btnPlayAgain"),
      analyze: document.getElementById("analyzeLink"),
      guessControls: document.getElementById("guessControls"),
      btnUndo: document.getElementById("btnUndo"),
      godModeBtn: document.getElementById("godModeBtn"),
    };

    // --- State ---
    let chess = new Chess();
    let board = null;
    let currentFen = "";
    let initialFen = "";
    let currentTbData = null;
    let streak = 0;
    let isUserTurn = false;
    let gameActive = false;
    let currentObjective = null;
    let selectedSquare = null;
    let cachedPositions = null;
    let cachedFilename = null;
    let godMode = false;
    let analysisMode = false;
    let streakInvalidated = false;

    function isReallyGameOver() {
        return chess.isCheckmate() || (chess.isDraw() && !chess.isThreefoldRepetition());
    }

    // --- Init Board ---
    board = new Chessboard(document.getElementById("board"), {
      assetsUrl: "https://cdn.jsdelivr.net/npm/cm-chessboard@8.11.5/assets/",
      position: "8/8/8/8/8/8/8/8", // "empty" keyword crashes, use explicit FEN
      orientation: COLOR.white,
      style: {
        pieces: { file: "pieces/standard.svg" },
        borderType: BORDER_TYPE.none
      },
      extensions: [{ class: Arrows }, { class: PromotionDialog }, { class: CustomMarkers }]
    });

    board.enableMoveInput((event) => {
        if (!isUserTurn || !gameActive) return false;

        switch (event.type) {
            case "moveInputStarted":
                const p = chess.get(event.square);
                // In Analysis Mode, allow picking up any piece relative to turn
                const isTurnColor = p && p.color === chess.turn();
                const isOurPiece = p && p.color === 'w';
                
                if (godMode || analysisMode ? isTurnColor : isOurPiece) {
                    if (selectedSquare === event.square) {
                        selectSquare(null);
                        return false; // Stop interaction on deselect
                    } else {
                        selectSquare(event.square);
                        return true;
                    }
                }
                return false;
                
            case "validateMoveInput":
                if (!gameActive && !godMode && !analysisMode) return false;
                try {
                    const temp = new Chess(chess.fen());
                    // Check if move is legal (ignoring promotion for now to check basic validity)
                    // We need to check if promotion is needed
                    const piece = temp.get(event.squareFrom);
                    const isPawn = piece && piece.type === 'p';
                    const targetRank = event.squareTo[1];
                    const isPromo = isPawn && (targetRank === '1' || targetRank === '8');
                    
                    if (isPromo) {
                        // Check if move is valid with 'q' promotion (just to validate geometry)
                        const m = temp.move({ from: event.squareFrom, to: event.squareTo, promotion: 'q' });
                        if (m) {
                            // Show dialog
                            // We return true to allow the piece to snap to the square, 
                            // then we'll handle the actual logic in moveInputFinished?
                            // No, cm-chessboard PromotionDialog usually works by returning true then callback?
                            // Actually, standard pattern is: return true, then use showPromotionDialog.
                            return true; 
                        }
                        return false;
                    }
                    
                    const m = temp.move({ from: event.squareFrom, to: event.squareTo, promotion: 'q' });
                    return !!m;
                } catch (e) { return false; }
                
            case "moveInputFinished":
                // Defer clearing to ensure it happens after any internal event handling
                setTimeout(() => selectSquare(null), 10);
                
                // Check for promotion
                const temp = new Chess(chess.fen());
                const sqFrom = event.squareFrom;
                const sqTo = event.squareTo;
                const piece = temp.get(sqFrom);
                const isPawn = piece && piece.type === 'p';
                const targetRank = sqTo[1];
                const isPromo = isPawn && (targetRank === '1' || targetRank === '8');

                if (event.legalMove) {
                    if (isPromo) {
                        // Show dialog
                        const side = piece.color === 'w' ? COLOR.white : COLOR.black;
                        board.showPromotionDialog(sqTo, side, (result) => {
                            if (result && result.piece) {
                                // Result piece name e.g. "wq", "wr", "bq" -> char 'q', 'r'
                                const promoChar = result.piece[1].toLowerCase();
                                // Execute move logic first (updates chess.js state)
                                handleUserMove(sqFrom, sqTo, promoChar).then(success => {
                                    if (success) {
                                        board.setPosition(chess.fen(), true);
                                    } else {
                                        console.error("Promotion move failed logic.");
                                        board.setPosition(chess.fen(), true);
                                    }
                                });
                            } else {
                                // Cancelled
                                board.setPosition(chess.fen(), true);
                            }
                        });
                        return true; // Let piece drop visually
                    } else {
                        handleUserMove(sqFrom, sqTo);
                    }
                }
                return true;
        }
    });

    // --- Event Listeners ---
    el.btnWin.addEventListener("click", () => handleGuess(2)); // Win for White
    el.btnDraw.addEventListener("click", () => handleGuess(0));
    el.btnLoss.addEventListener("click", () => handleGuess(-2));
    
    el.btnNew.addEventListener("click", startNewGame);
    el.btnPlayAgain.addEventListener("click", startNewGame);
    el.btnUndo.addEventListener("click", undoLastMove);
    
    if (el.godModeBtn) {
        el.godModeBtn.addEventListener("click", () => {
            if (godMode) return; // Cannot turn OFF via this button as per request
            
            godMode = true;
            el.godModeBtn.classList.add("active");
            
            // Clear selection/markers on toggle to prevent stale state
            selectSquare(null);
            clearArrows();

            gameActive = true; // Ensure movement is allowed
            analysisMode = false;
            streakInvalidated = true;
            const turnStr = chess.turn() === 'w' ? "White" : "Black";
            setStatus(null, `Analysis Mode On: ${turnStr} to move.`);
            setGuessEnabled(false);
            el.guessControls.classList.add("hidden");
        });
    }

    async function undoLastMove() {
        // Allow undo even if gameActive is false (e.g. after blunder endGame)
        
        // If it's black's turn (user just played and blundered), undo 1 move.
        // If it's white's turn (normal flow), undo 2 moves.
        
        if (chess.turn() === 'b') {
             chess.undo();
        } else {
             chess.undo();
             chess.undo();
        }

        currentFen = chess.fen();
        await board.setPosition(currentFen, true);
        
        // Refresh TB Data
        try {
            currentTbData = await fetchTablebase(currentFen);
            
            // Re-evaluate state
            gameActive = true; // Reactivate game
            isUserTurn = true;
            
            if (godMode || analysisMode) {
                const turnStr = chess.turn() === 'w' ? "White" : "Black";
                if (godMode) setStatus(null, `Analysis Mode On: ${turnStr} to move.`);
                else setStatus(null, `Analysis Mode Off: ${turnStr} to move.`);
            } else if (!el.btnWin.classList.contains("hidden")) {
                setStatus(null, "Guess result or Play a move.");
            } else {
                setStatus(null, "");
            }
            
            clearArrows();
            
            if (chess.history().length === 0) {
                 el.btnUndo.classList.add("hidden");
            }
        } catch(e) { console.error(e); }
    }

    function selectSquare(sq) {
        clearArrows(); // Clear arrows on selection
        board.removeMarkers(MARKER_SOURCE);
        board.removeMarkers(MARKER_DEST);
        board.removeMarkers(MARKER_SELECTED); // Cleanup old
        board.removeMarkers(MARKER_GOD_WIN);
        board.removeMarkers(MARKER_GOD_DRAW);
        board.removeMarkers(MARKER_GOD_LOSS);
        
        selectedSquare = sq;
        if (selectedSquare) {
            // Add Source Marker
            board.addMarker(MARKER_SOURCE, selectedSquare);
            
            if (godMode && currentTbData && currentTbData.moves) {
                // Analysis Mode: Use TB data to color destinations
                // Filter moves starting from selectedSquare
                const moves = currentTbData.moves.filter(m => m.uci.startsWith(selectedSquare));
                
                // Aggregate by destination to handle promotions (pick best outcome)
                const destMap = new Map();
                
                moves.forEach(m => {
                    const dest = m.uci.slice(2, 4);
                    const wdl = categoryToWdl(m.category); // 2, 0, -2
                    
                    if (!destMap.has(dest)) {
                        destMap.set(dest, wdl);
                    } else {
                        const currentBest = destMap.get(dest);
                        // We want the MIN value (Loss for opponent = -2 is best for us)
                        if (wdl < currentBest) {
                            destMap.set(dest, wdl);
                        }
                    }
                });
                
                destMap.forEach((wdl, dest) => {
                    let marker = MARKER_GOD_DRAW;
                    if (wdl === -2) marker = MARKER_GOD_WIN;   // Opponent Loses -> I Win -> Green
                    else if (wdl === 2) marker = MARKER_GOD_LOSS; // Opponent Wins -> I Lose -> Red
                    
                    board.addMarker(marker, dest);
                });
                
            } else {
                // Standard Mode: Show valid destinations (green dots)
                const moves = chess.moves({ square: selectedSquare, verbose: true });
                moves.forEach(m => {
                    board.addMarker(MARKER_DEST, m.to);
                });
            }
        }
    }

    // --- Persistence ---
    function saveSettings() {
        try {
            const sel = document.getElementById("endgameSelect");
            const val = sel.value;
            localStorage.setItem("endgame-trainer-selection", val);
        } catch(e) { console.warn("Could not save settings", e); }
    }

    function loadSettings() {
        try {
            const val = localStorage.getItem("endgame-trainer-selection");
            if (val) {
                const sel = document.getElementById("endgameSelect");
                if (sel) {
                    sel.value = val;
                }
            }
        } catch(e) { console.warn("Could not load settings", e); }
    }
    
    // Init Persistence
    loadSettings();
    const sel = document.getElementById('endgameSelect');
    if(sel) sel.addEventListener('change', () => {
        saveSettings();
        startNewGame();
    });

    // Start
    console.log("Starting game loop...");
    startNewGame();


    // --- Core Logic ---

    async function startNewGame() {
        console.log("startNewGame called");
        gameActive = false;
        isUserTurn = false;
        currentTbData = null;
        clearArrows();
        selectSquare(null);
        setGuessEnabled(false);
        if(el.btnPlayAgain) el.btnPlayAgain.classList.add("hidden");
        el.btnWin.classList.remove("hidden");
        el.btnDraw.classList.remove("hidden");
        el.btnLoss.classList.remove("hidden");
        if(el.guessControls) el.guessControls.classList.remove("hidden");
        if(el.btnUndo) el.btnUndo.classList.add("hidden");
        if(el.godModeBtn) {
            el.godModeBtn.classList.remove("active");
        }
        godMode = false;
        analysisMode = false;
        streakInvalidated = false;
        setStatus("warn", "Generating position...");
        
        try {
            console.log("Generating valid position...");
            const fen = await generateValidPosition();
            console.log("Position generated:", fen);
            
            currentFen = fen;
            initialFen = fen;
            console.log("Loading into Chess.js...");
            try {
                chess.load(fen);
            } catch(loadErr) {
                throw new Error("Chess.load failed on FEN: " + fen + " :: " + loadErr);
            }
            
            console.log("Setting board position...");
            await board.setPosition(fen, true);
            
            // Get initial TB data
            console.log("Fetching TB data...");
            currentTbData = await fetchTablebase(fen);
            console.log("TB Data received", currentTbData);
            
            // Set Objective
            // normalize wdl from category if needed handled in fetchTablebase
            
            updateLinks(initialFen);
            setStatus(null, "Guess result or Play a move.");
            setGuessEnabled(true);
            gameActive = true;
            isUserTurn = true;

        } catch (e) {
            console.error(e);
            setStatus("bad", "Error: " + e.message);
        }
    }

        async function handleUserMove(from, to, promotion = 'q') {

            console.log("handleUserMove called with:", from, to, promotion);

            clearArrows();

            selectSquare(null);

    

            if (!gameActive) {

                console.warn("handleUserMove aborted: gameActive is false");

                return;

            }

    

            // Move is valid (already checked by cm-chessboard)

            try {

                const moveResult = chess.move({ from, to, promotion });

                if (!moveResult) {

                    console.error("chess.move failed for:", { from, to, promotion });

                    console.log("Current FEN:", chess.fen());

                    console.log("Turn:", chess.turn());

                    return false;

                }

                console.log("chess.move success:", moveResult);

            } catch (err) {

                console.error("chess.move threw error:", err);

                return false;

            }

            

            await handleUserMovePostProcess();

            return true;

        }

    

        async function handleUserMovePostProcess() {

            // Analysis Mode / Sandbox Bypass

            if (godMode || analysisMode) {

                 currentFen = chess.fen();

                 await board.setPosition(currentFen, true); // Ensure board sync

                 

                 // Update Undo visibility

                 if (el.btnUndo && chess.history().length > 0) el.btnUndo.classList.remove("hidden");

    

                 try {

                    currentTbData = await fetchTablebase(currentFen);

                    const turnStr = chess.turn() === 'w' ? "White" : "Black";

                    

                    if (godMode) {

                        setStatus(null, `Analysis Mode On: ${turnStr} to move.`);

                    } else {

                        setStatus(null, `Analysis Mode Off: ${turnStr} to move.`);

                    }

                    

                                    if (isReallyGameOver()) {

                    

                                        handleGameOver();

                    

                                    }

                    

                                 } catch(e) { console.error(e); }

                    

                                 return true;

                    

                            }

    

            isUserTurn = false;

            setStatus("warn", "Thinking...");

    

            // Evaluate Move

            const prevWdl = currentTbData.wdl;

            

            // Fetch new data

            try {

                const newFen = chess.fen();

                console.log("Fetching response for FEN:", newFen);

                const newData = await fetchTablebase(newFen);

                console.log("Response received:", newData);

                

                // Check blunder

                // White moved. Now Black to move.

                // If White was Winning (2), Black should be Losing (-2).

                // If White was Drawing (0), Black should be Drawing (0).

                

                let failed = false;

                let msg = "";

    

                if (prevWdl === 2) { // We were winning

                     if (newData.wdl !== -2) { // Opponent not losing

                         failed = true;

                         // newData.wdl: 2 (Opponent Wins) -> We Lost

                         // newData.wdl: 0 (Draw) -> We Drew

                         const outcome = newData.wdl === 2 ? "Loss" : "Draw";

                         msg = `Blunder! You turned a Win into a ${outcome}.`;

                     }

                } else if (prevWdl === 0) { // Drawing

                     if (newData.wdl === 2) { // Opponent Winning

                         failed = true;

                         msg = "Blunder! You turned a Draw into a Loss.";

                     }

                }

                

                if (failed) {

                    endGame(false, msg);

                    if (el.btnUndo) el.btnUndo.classList.remove("hidden");

                    // Revert board to show? No, keep it.

                    return;

                }

    

                if (isReallyGameOver()) {

                    handleGameOver();

                    return;

                }

    

                // Computer Reply (Best Move)

                if (newData.moves && newData.moves.length > 0) {

                    let bestMove = newData.moves[0];

                    console.log("Computer best move (default):", bestMove.uci);

    

                    // Tie-break for Draw: Prefer no capture

                    const bestWdl = categoryToWdl(bestMove.category);

                    if (bestWdl === 0) { // If best outcome is Draw

                        // Filter moves that preserve the Draw

                        const drawMoves = newData.moves.filter(m => categoryToWdl(m.category) === 0);

                        

                        // Look for non-capture among draw moves

                        // Using SAN to detect capture ('x')

                        const nonCapture = drawMoves.find(m => m.san && !m.san.includes('x'));

                        

                        if (nonCapture) {

                            console.log("Switched to non-capture draw move:", nonCapture.uci);

                            bestMove = nonCapture;

                        }

                    }

    

                    const uci = bestMove.uci;

                    const fromC = uci.slice(0, 2);

                    const toC = uci.slice(2, 4);

                    const promoC = uci.length > 4 ? uci[4] : undefined; // e.g. "a7a8q" -> 'q'

                    

                    chess.move({ from: fromC, to: toC, promotion: promoC || 'q' });

                    await board.setPosition(chess.fen(), true);

                    

                    if (isReallyGameOver()) {

                        handleGameOver();

                        return;

                    }

                    

                    // Update state

                    currentFen = chess.fen();

                    currentTbData = await fetchTablebase(currentFen);

                    

                    isUserTurn = true;

                    if (!el.btnWin.classList.contains("hidden")) {

                        setStatus(null, "Guess result or Play a move.");

                    } else {

                        setStatus(null, "");

                    }

                    

                    if (el.btnUndo && chess.history().length > 0) {

                        el.btnUndo.classList.remove("hidden");

                    }

                    // updateLinks removed

                } else {

                    handleGameOver();

                }

    

            } catch (e) {

                setStatus("bad", "Error: " + e.message);

            }

        }

    function handleGuess(guessWdl) {
        if (!gameActive) return;
        drawOutcomeArrows(currentTbData);
        
        const actualWdl = currentTbData.wdl;
        
        let correct = (guessWdl === actualWdl);
        
        if (correct) {
            if (!streakInvalidated) {
                streak++;
                updateStreak();
            }
            setStatus("ok", `Correct! It is a ${wdlToString(actualWdl)}.`);
        } else {
            streak = 0;
            updateStreak();
            setStatus("bad", `Wrong. It is a ${wdlToString(actualWdl)}.`);
        }
        setGuessEnabled(false);
        // Hide only guess buttons
        el.btnWin.classList.add("hidden");
        el.btnDraw.classList.add("hidden");
        el.btnLoss.classList.add("hidden");
        // Analysis Mode toggle is always visible now
    }

    async function handleGameOver() {
        let success = false;
        let msg = "";
        
        // Determine Actual Result from User's Perspective (White)
        // 1 = Win, 0 = Draw, -1 = Loss
        let actualResult = 0; 
        
        if (chess.isCheckmate()) {
            if (chess.turn() === 'b') actualResult = 1; // White mated Black
            else actualResult = -1; // Black mated White
        } else {
            actualResult = 0; // Stalemate, Insufficient Material, etc.
        }

        // Determine Theoretical Outcome of the STARTING position
        // We need to fetch or store the initial WDL. 
        // currentTbData tracks current position. 
        // Let's fetch initial position WDL again or store it in startNewGame.
        // For now, let's just fetch it to be safe (or assume initialFen is valid).
        
        let initialWdl = 0;
        try {
            const initData = await fetchTablebase(initialFen);
            // initData.wdl: 2 (Win), 0 (Draw), -2 (Loss)
            if (initData.wdl === 2) initialWdl = 1;
            else if (initData.wdl === -2) initialWdl = -1;
            else initialWdl = 0;
        } catch(e) { console.error("Could not fetch initial WDL", e); }

        // Logic
        if (actualResult === 1) {
            // User Won
            success = true;
            if (initialWdl === 1) msg = "You won a winning position.";
            else if (initialWdl === 0) msg = "You won a drawn position!";
            else msg = "You won a lost position!"; // Analysis Mode or miracle
        } else if (actualResult === -1) {
            // User Lost
            if (initialWdl === 1) {
                success = false;
                msg = "You lost a winning position.";
            } else if (initialWdl === 0) {
                success = false;
                msg = "You lost a drawn position.";
            } else {
                success = true; // Expected loss achieved? usually failure in training but ok here
                msg = "You lost a lost position.";
            }
        } else {
            // Draw
            if (initialWdl === 1) {
                success = false;
                msg = "You drew a winning position.";
            } else if (initialWdl === 0) {
                success = true;
                msg = "You drew a drawn position.";
            } else {
                success = true; // Saved a draw!
                msg = "You drew a lost position!";
            }
        }

        if (success) {
            if (!streakInvalidated) {
                streak++;
                updateStreak();
            }
            setStatus("ok", msg); // Green
        } else {
            // Reset streak on failure
            streak = 0;
            updateStreak();
            setStatus("bad", msg); // Red
        }
        
        endGame(success, msg);
    }

    function endGame(success, msg) {
        gameActive = false;
        isUserTurn = false;
        setStatus(success ? "ok" : "bad", msg);
        setGuessEnabled(false);
        
        el.btnWin.classList.add("hidden");
        el.btnDraw.classList.add("hidden");
        el.btnLoss.classList.add("hidden");
        
        if (!success) {
            streak = 0;
            updateStreak();
        }
        // Analysis Mode toggle is always visible now
    }

    // --- Generation & Validation Logic ---

    async function generateValidPosition() {
        // 1. Determine Piece Composition from UI
        let { w, b } = getSelectedPieces();
        
        // Ensure Kings
        if(!w.includes('K')) w.push('K');
        if(!b.includes('K')) b.push('K');

        // 2. Sort Pieces to match file format (K, Q, R, B, N, P)
        const sortOrder = (p) => PIECE_ORDER.indexOf(p);
        w.sort((a, b) => sortOrder(a) - sortOrder(b));
        b.sort((a, b) => sortOrder(a) - sortOrder(b));

        // 3. Construct File Path
        const filename = `${w.join('')}_${b.join('')}.txt`;
        const url = `out/${filename}`; // Relative path

        let text = "";

        // Check Cache
        if (cachedFilename === filename && cachedPositions) {
            console.log(`Using cached positions for: ${filename}`);
            text = cachedPositions;
        } else {
            console.log(`Cache miss. Fetching positions from: ${url}`);
            setStatus("warn", "Fetching position...");

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`No positions found for material: ${w.join('')} vs ${b.join('')}. (File ${filename} missing)`);
                    }
                    throw new Error(`Network error: ${response.status} ${response.statusText}`);
                }

                text = await response.text();
                if (!text) throw new Error("Position file is empty.");
                
                // Update Cache
                cachedPositions = text;
                cachedFilename = filename;

            } catch (e) {
                console.error(e);
                throw new Error(e.message);
            }
        }

        // 4. Calculate Record Details
        const flatList = [
            ...w.map(p => ({ type: p, color: 'w' })),
            ...b.map(p => ({ type: p, color: 'b' }))
        ];
        const recordLength = flatList.length;

        if (text.length % recordLength !== 0) {
            console.warn(`File length (${text.length}) is not a multiple of record length (${recordLength}). Trimming end.`);
        }

        const totalRecords = Math.floor(text.length / recordLength);
        if (totalRecords === 0) throw new Error("File contains no complete records.");

        // 5. Pick Random Record
        const randomIndex = Math.floor(Math.random() * totalRecords);
        const startOffset = randomIndex * recordLength;
        const record = text.substring(startOffset, startOffset + recordLength);

        console.log(`Selected record #${randomIndex}: ${record}`);

        // 6. Decode Record to Board/FEN
        // ALPHABET index -> 0..63.
        // 0 = a1, 1 = b1 ... 7 = h1, 8 = a2 ...
        
        const grid = Array(8).fill(null).map(() => Array(8).fill(""));

        for (let i = 0; i < recordLength; i++) {
            const char = record[i];
            const val = ALPHABET.indexOf(char);
            if (val === -1) throw new Error(`Invalid character '${char}' in record.`);

            const file = val % 8;       // 0-7 (a-h)
            const rank = Math.floor(val / 8); // 0-7 (1-8)

            // Grid usually indexed [row][col] where row 0 is top (rank 8)
            // row index = 7 - rank
            const gridRow = 7 - rank;
            const gridCol = file;

            const pieceDef = flatList[i];
            const pChar = pieceDef.type.toUpperCase();
            grid[gridRow][gridCol] = (pieceDef.color === 'w' ? pChar : pChar.toLowerCase());
        }

        // 7. Build FEN String
        let fenRows = grid.map(row => {
            let empty = 0;
            let str = "";
            row.forEach(c => {
                if (c === "") empty++;
                else {
                    if (empty > 0) str += empty;
                    empty = 0;
                    str += c;
                }
            });
            if (empty > 0) str += empty;
            return str;
        });
        
        const fen = fenRows.join("/") + " w - - 0 1";
        return fen;
    }

    // --- Helpers ---

    function clearArrows() {
        if (typeof board.removeArrows === "function") board.removeArrows();
    }

    function uciToArrow(uci) {
        if (typeof uci !== "string" || uci.length < 4) return null;
        const from = uci.slice(0, 2);
        const to = uci.slice(2, 4);
        if (!/^[a-h][1-8]$/.test(from) || !/^[a-h][1-8]$/.test(to)) return null;
        return { from, to };
    }

    function categoryToWdl(category) {
        const c = String(category || "").toLowerCase();
        if (c.includes("win")) return 2;
        if (c.includes("loss")) return -2;
        if (c.includes("draw")) return 0;
        return null;
    }

    function drawOutcomeArrows(tbData) {
        clearArrows();
        const moves = Array.isArray(tbData?.moves) ? tbData.moves : [];
        if (!moves.length) return;

        // Map category to WDL and determine if any move is winning for current player
        const movesWithWdl = moves.map(m => ({ ...m, wdl: categoryToWdl(m.category) }));
        
        // Collect unique outcomes present
        const outcomes = new Set(movesWithWdl.map(m => m.wdl));
        
        // If all moves have the same outcome, show nothing
        if (outcomes.size <= 1) return;

        const hasWinningMove = movesWithWdl.some(m => m.wdl === -2);

        for (const m of movesWithWdl) {
            const arrow = uciToArrow(m.uci);
            if (!arrow) continue;
            
            if (m.wdl === null) continue;

            // Filter Logic:
            // 1. Hide Losing moves (wdl === 2)
            if (m.wdl === 2) continue;
            
            // 2. If winning moves exist, hide drawing moves
            if (hasWinningMove && m.wdl === 0) continue;

            // Convert TB WDL to our color WDL
            // Opponent Loss (-2) = Our Win (2) -> Green
            const moveWdl = -m.wdl; 

            let arrowType = null;
            if (moveWdl === 2) arrowType = ARROW_WIN;
            else if (moveWdl === 0) arrowType = ARROW_DRAW;
            else if (moveWdl === -2) arrowType = ARROW_LOSS;

            if (arrowType) {
                board.addArrow(arrowType, arrow.from, arrow.to);
            }
        }
    }

    function getSelectedPieces() {
        const val = document.getElementById("endgameSelect").value;
        const [whitePart, blackPart] = val.split('_');
        const w = whitePart.split(''); // e.g. "KP" -> ['K', 'P']
        const b = blackPart.split(''); // e.g. "KR" -> ['K', 'R']
        return { w, b };
    }

    async function fetchTablebase(fen) {
        const url = TABLEBASE_URL + encodeURIComponent(fen);
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        
        // Normalize
        if (typeof data.wdl === 'undefined' && data.category) {
            const cat = data.category;
            if (cat === 'win') data.wdl = 2;
            else if (cat === 'loss') data.wdl = -2;
            else if (cat === 'draw') data.wdl = 0;
            else data.wdl = 0;
        }
        return data;
    }

    function setStatus(kind, text) {
        el.status.textContent = text;
        el.status.className = "status " + (kind || "");
    }

    function setGuessEnabled(en) {
        el.btnWin.disabled = !en;
        el.btnDraw.disabled = !en;
        el.btnLoss.disabled = !en;
    }

    function updateStreak() {
        el.streak.textContent = streak;
    }

    function wdlToString(wdl) {
        if (wdl > 0) return "Win";
        if (wdl < 0) return "Loss";
        return "Draw";
    }
    
    function updateLinks(fen) {
        el.analyze.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
        el.analyze.removeAttribute("aria-disabled");
    }

  </script>
</body>
</html>
