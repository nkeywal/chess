<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>K+P vs K Quiz (Lichess Tablebase)</title>

  <!-- cm-chessboard (board + pieces) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/chessboard.css">
  <!-- cm-chessboard arrows extension -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/extensions/arrows/arrows.css">

  <style>
    :root {
      --bg: #0b0f17;
      --panel: #111828;
      --panel2: #0f1624;
      --text: #e7eefc;
      --muted: #a9b6cf;
      --border: rgba(231, 238, 252, 0.12);
      --shadow: 0 14px 40px rgba(0,0,0,0.35);
      --btn: #1c2a44;
      --btnHover: #243659;

      /* sizing knobs */
      --pagePad: 24px;
      --cardPad: 16px;
      --gap: 18px;

      /* default board size (desktop/tablet) */
      --boardSize: min(560px, 68vh);
    }

    @media (max-width: 900px) {
      :root { --gap: 14px; }
    }

    /* MOBILE FIXES (requested):
       - prevent horizontal clipping (file "h" cut)
       - keep Play Again / Analyze visible without scrolling on a standard phone */
    @media (max-width: 600px) {
      :root {
        --pagePad: 10px;     /* reduce wasted width */
        --cardPad: 10px;     /* reduce wasted width */
        --gap: 10px;

        /* smaller board so the controls fit in the first screen */
        --boardSize: min(96vw, 44svh, 520px);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 50% 0%, #162445 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100svh;
      padding: var(--pagePad);
      display: grid;
      place-items: center;
    }

    .app {
      width: min(980px, 100%);
      display: grid;
      gap: var(--gap);
    }

    header {
      display: flex;
      gap: 12px;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    header h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.2px;
    }

    header .hint {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }

    @media (max-width: 600px) {
      header h1 { font-size: 18px; }
      header .hint { font-size: 12px; }
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: var(--gap);
      align-items: start;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .boardCard {
      padding: var(--cardPad);
      display: grid;
      place-items: center;
    }

    /* Board sizing wrapper:
       - never overflow horizontally (fix "h" clipped)
       - do NOT clip the board here (wrapper stays visible); clipping is on #board itself */
    .boardSizer {
      width: min(100%, var(--boardSize));
      height: min(100%, var(--boardSize));
      overflow: visible; /* IMPORTANT: avoid cutting last file/rank due to fractional rendering */
    }

    #board {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden; /* clip to rounded corners here, not on the wrapper */
    }

    .sideCard {
      padding: var(--cardPad);
      display: grid;
      gap: 10px;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      color: var(--muted);
      font-size: 13px;
      background: rgba(255,255,255,0.03);
    }

    .pill strong { color: var(--text); font-weight: 650; }

    .status {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
      color: var(--muted);
      font-size: 14px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .status.ok   { border-color: rgba(46, 204, 113, 0.35); color: rgba(46, 204, 113, 0.95); }
    .status.bad  { border-color: rgba(255, 92, 92, 0.35); color: rgba(255, 92, 92, 0.95); }
    .status.warn { border-color: rgba(255, 204, 102, 0.35); color: rgba(255, 204, 102, 0.95); }

    .btnRow {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .btnRow2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button, a.linkBtn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 650;
      letter-spacing: 0.2px;
      transition: transform 0.04s ease, background 0.15s ease, opacity 0.15s ease;
      text-align: center;
      text-decoration: none;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      min-height: 42px;
    }
    button:hover, a.linkBtn:hover { background: var(--btnHover); }
    button:active, a.linkBtn:active { transform: translateY(1px); }
    button:disabled, a.linkBtn[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    /* Mobile: slightly tighter controls to avoid scrolling */
    @media (max-width: 600px) {
      .sideCard { gap: 9px; }
      .pill { font-size: 12px; padding: 7px 9px; }
      .status { font-size: 13px; padding: 9px 10px; }
      button, a.linkBtn { min-height: 40px; padding: 9px 10px; }
      .btnRow, .btnRow2 { gap: 8px; }
    }

    details {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
      overflow: hidden;
    }

    summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      color: var(--muted);
      font-weight: 650;
      user-select: none;
    }
    summary::-webkit-details-marker { display: none; }

    .detailsBody {
      padding: 10px 12px 12px 12px;
      border-top: 1px solid var(--border);
      display: grid;
      gap: 8px;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size: 12px;
      color: rgba(231, 238, 252, 0.88);
      word-break: break-word;
    }

    .smallLabel {
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <h1>K+P vs K — Tablebase Quiz</h1>
      <p class="hint">Always White to move. Outcome is from White’s perspective (Win / Draw / Loss).</p>
    </header>

    <section class="layout">
      <div class="card boardCard">
        <div class="boardSizer">
          <div id="board" aria-label="Chessboard"></div>
        </div>
      </div>

      <div class="card sideCard">
        <div class="row">
          <div class="pill">Current Streak: <strong id="streak">0</strong></div>
          <div class="pill">Status: <strong id="loading">Ready</strong></div>
        </div>

        <div id="status" class="status">Tap “Play Again” to start.</div>

        <div class="btnRow">
          <button id="btnWin"  type="button">Win</button>
          <button id="btnDraw" type="button">Draw</button>
          <button id="btnLoss" type="button">Loss</button>
        </div>

        <div class="btnRow2">
          <button id="btnAgain" type="button">Play Again</button>
          <a id="analyzeLink" class="linkBtn" href="#" target="_blank" rel="noopener noreferrer" aria-disabled="true">Analyze on Lichess</a>
        </div>

        <details id="details">
          <summary>Details</summary>
          <div class="detailsBody">
            <div>
              <div class="smallLabel">Best move(s):</div>
              <div id="bestMoves" class="mono">—</div>
            </div>
            <div>
              <div class="smallLabel">DTZ:</div>
              <div id="dtz" class="mono">—</div>
            </div>
            <div>
              <div class="smallLabel">FEN:</div>
              <div id="fen" class="mono">—</div>
            </div>
          </div>
        </details>
      </div>
    </section>
  </div>

  <script type="module">
    import { Chessboard, COLOR, BORDER_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/Chessboard.js";
    import { Arrows, ARROW_TYPE } from "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/src/extensions/arrows/Arrows.js";

    const TABLEBASE_URL = "https://tablebase.lichess.ovh/standard?fen=";

    const GEN = {
      attempts: 30,
      pawnColorBlackChance: 0.30,
      pawnRankMin: 3,
      pawnRankMax: 6,
      kingNearMin: 1,
      kingNearMax: 4,
      requireAtLeastOneKingVeryClose: 2,
      trivialAbsDtzMax: 3
    };

    const el = {
      streak: document.getElementById("streak"),
      loading: document.getElementById("loading"),
      status: document.getElementById("status"),
      fen: document.getElementById("fen"),
      dtz: document.getElementById("dtz"),
      bestMoves: document.getElementById("bestMoves"),
      analyze: document.getElementById("analyzeLink"),
      btnWin: document.getElementById("btnWin"),
      btnDraw: document.getElementById("btnDraw"),
      btnLoss: document.getElementById("btnLoss"),
      btnAgain: document.getElementById("btnAgain"),
    };

    let streak = 0;
    let answered = false;
    let currentFen = null;
    let currentTb = null;

    const board = new Chessboard(document.getElementById("board"), {
      assetsUrl: "https://cdn.jsdelivr.net/npm/cm-chessboard@8.7.8/assets/",
      position: "8/8/8/8/8/8/8/8",
      orientation: COLOR.white,
      style: {
        pieces: { file: "pieces/standard.svg" },
        borderType: BORDER_TYPE.frame
      },
      extensions: [{ class: Arrows }]
    });

    const FILES = "abcdefgh";

    function randInt(min, maxInclusive) {
      return Math.floor(Math.random() * (maxInclusive - min + 1)) + min;
    }
    function choice(arr) { return arr[randInt(0, arr.length - 1)]; }

    function sqToXY(sq) {
      return { x: FILES.indexOf(sq[0]), y: parseInt(sq[1], 10) - 1 };
    }
    function xyToSq(x, y) {
      return FILES[x] + String(y + 1);
    }
    function onBoard(x, y) { return x >= 0 && x < 8 && y >= 0 && y < 8; }
    function chebDist(aSq, bSq) {
      const a = sqToXY(aSq), b = sqToXY(bSq);
      return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));
    }
    function kingsAdjacent(wk, bk) { return chebDist(wk, bk) <= 1; }

    function kingCanCapture(targetSq, kingSq, otherKingSq) {
      if (chebDist(kingSq, targetSq) !== 1) return false;
      return chebDist(targetSq, otherKingSq) >= 2;
    }

    function randomSquareNear(baseSq, minD, maxD, forbiddenSet) {
      const base = sqToXY(baseSq);
      for (let t = 0; t < 80; t++) {
        const dx = randInt(-maxD, maxD);
        const dy = randInt(-maxD, maxD);
        if (dx === 0 && dy === 0) continue;
        const d = Math.max(Math.abs(dx), Math.abs(dy));
        if (d < minD || d > maxD) continue;
        const x = base.x + dx, y = base.y + dy;
        if (!onBoard(x, y)) continue;
        const sq = xyToSq(x, y);
        if (forbiddenSet && forbiddenSet.has(sq)) continue;
        return sq;
      }
      return null;
    }

    function piecesToFen({ wk, bk, pawnSq, pawnColor }) {
      const grid = Array.from({ length: 8 }, () => Array(8).fill(""));
      const place = (sq, ch) => {
        const { x, y } = sqToXY(sq);
        grid[y][x] = ch;
      };
      place(wk, "K");
      place(bk, "k");
      place(pawnSq, pawnColor === "w" ? "P" : "p");

      const ranks = [];
      for (let y = 7; y >= 0; y--) {
        let run = 0;
        let s = "";
        for (let x = 0; x < 8; x++) {
          const ch = grid[y][x];
          if (!ch) run++;
          else {
            if (run > 0) { s += String(run); run = 0; }
            s += ch;
          }
        }
        if (run > 0) s += String(run);
        ranks.push(s || "8");
      }
      return `${ranks.join("/")} w - - 0 1`;
    }

    function lichessFenPath(fen) {
      return fen.trim().replace(/\s+/g, "_");
    }

    function setAnalyzeLink(fen) {
      const href = fen ? `https://lichess.org/analysis/standard/${lichessFenPath(fen)}` : "#";
      el.analyze.href = href;
      el.analyze.setAttribute("aria-disabled", fen ? "false" : "true");
      el.analyze.style.pointerEvents = fen ? "auto" : "none";
      el.analyze.style.opacity = fen ? "1" : "0.55";
    }

    async function fetchTablebase(fen) {
      const url = TABLEBASE_URL + encodeURIComponent(fen);
      const res = await fetch(url);
      if (!res.ok) {
        const text = await res.text().catch(() => "");
        throw new Error(`Tablebase error: HTTP ${res.status}${text ? " — " + text.slice(0, 120) : ""}`);
      }
      return await res.json();
    }

    function coarseWDL(cat) {
      const s = String(cat || "").toLowerCase();
      if (s.includes("win")) return "win";
      if (s.includes("loss")) return "loss";
      if (s.includes("draw")) return "draw";
      return "unknown";
    }

    function invertWDL(wdl) {
      if (wdl === "win") return "loss";
      if (wdl === "loss") return "win";
      return wdl;
    }

    function prettyOutcome(wdl) {
      if (wdl === "win") return "Win (White)";
      if (wdl === "draw") return "Draw";
      if (wdl === "loss") return "Loss (White)";
      return "Unknown";
    }

    function uciToArrow(uci) {
      if (typeof uci !== "string" || uci.length < 4) return null;
      const from = uci.slice(0, 2);
      const to = uci.slice(2, 4);
      if (!FILES.includes(from[0]) || !FILES.includes(to[0])) return null;
      if (!"12345678".includes(from[1]) || !"12345678".includes(to[1])) return null;
      return { from, to };
    }

    function clearArrows() {
      if (typeof board.removeArrows === "function") board.removeArrows();
    }

    function drawBestMoveArrows(bestMoves) {
      clearArrows();
      for (const m of bestMoves) {
        const arrow = uciToArrow(m.uci);
        if (!arrow) continue;
        board.addArrow(ARROW_TYPE.default, arrow.from, arrow.to);
      }
    }

    function bestMovesFromTb(tbJson) {
      const moves = Array.isArray(tbJson?.moves) ? tbJson.moves : [];
      if (!moves.length) return [];

      const top = moves[0];
      const topBlackWdl = coarseWDL(top.category);
      const topWhiteWdl = invertWDL(topBlackWdl);

      const topDtzRaw = (typeof top.precise_dtz === "number") ? top.precise_dtz
                    : (typeof top.dtz === "number") ? top.dtz
                    : null;
      const topWhiteDtz = (topDtzRaw === null) ? null : -topDtzRaw;

      return moves
        .map(m => {
          const blackWdl = coarseWDL(m.category);
          const whiteWdl = invertWDL(blackWdl);
          const dtzRaw = (typeof m.precise_dtz === "number") ? m.precise_dtz
                       : (typeof m.dtz === "number") ? m.dtz
                       : null;
          const whiteDtz = (dtzRaw === null) ? null : -dtzRaw;
          return { uci: m.uci, san: m.san, whiteWdl, whiteDtz };
        })
        .filter(m => m.whiteWdl === topWhiteWdl && m.whiteDtz === topWhiteDtz);
    }

    function setLoading(text, isBusy) {
      el.loading.textContent = text;
      el.btnAgain.disabled = !!isBusy;
      setGuessEnabled(!isBusy && !answered);
    }

    function setGuessEnabled(enabled) {
      el.btnWin.disabled = !enabled;
      el.btnDraw.disabled = !enabled;
      el.btnLoss.disabled = !enabled;
    }

    function setStatus(kind, text) {
      el.status.classList.remove("ok", "bad", "warn");
      if (kind) el.status.classList.add(kind);
      el.status.textContent = text;
    }

    function updateStreakDisplay() {
      el.streak.textContent = String(streak);
    }

    function setDetails({ fen, dtz, bestMovesSAN }) {
      el.fen.textContent = fen || "—";
      el.dtz.textContent = (dtz === null || dtz === undefined) ? "—" : String(dtz);
      el.bestMoves.textContent = bestMovesSAN || "—";
    }

    function generateCandidatePosition() {
      const pawnColor = Math.random() < GEN.pawnColorBlackChance ? "b" : "w";

      const pawnFile = choice([...FILES]);
      const pawnRank = randInt(GEN.pawnRankMin, GEN.pawnRankMax);
      const pawnSq = pawnFile + String(pawnRank);

      const forbidden = new Set([pawnSq]);

      const wk = randomSquareNear(pawnSq, GEN.kingNearMin, GEN.kingNearMax, forbidden);
      if (!wk) return null;
      forbidden.add(wk);

      let bk = null;
      for (let t = 0; t < 60; t++) {
        const cand = randomSquareNear(pawnSq, GEN.kingNearMin, GEN.kingNearMax, forbidden);
        if (!cand) continue;
        if (kingsAdjacent(wk, cand)) continue;
        bk = cand;
        break;
      }
      if (!bk) return null;

      const dW = chebDist(wk, pawnSq);
      const dB = chebDist(bk, pawnSq);
      if (Math.min(dW, dB) > GEN.requireAtLeastOneKingVeryClose) return null;

      if (pawnColor === "w" && kingCanCapture(pawnSq, bk, wk)) return null;
      if (pawnColor === "b" && kingCanCapture(pawnSq, wk, bk)) return null;

      const fen = piecesToFen({ wk, bk, pawnSq, pawnColor });
      return { fen };
    }

    async function generateInterestingPosition() {
      let lastOk = null;

      for (let i = 0; i < GEN.attempts; i++) {
        const cand = generateCandidatePosition();
        if (!cand) continue;

        try {
          const tb = await fetchTablebase(cand.fen);
          if (tb?.checkmate || tb?.stalemate) continue;

          if (typeof tb?.dtz === "number" && Math.abs(tb.dtz) <= GEN.trivialAbsDtzMax) {
            lastOk = { fen: cand.fen, tb };
            continue;
          }

          if (!Array.isArray(tb?.moves) || tb.moves.length === 0) continue;

          return { fen: cand.fen, tb };
        } catch {
          continue;
        }
      }

      if (lastOk) return lastOk;

      for (let i = 0; i < 20; i++) {
        const cand = generateCandidatePosition();
        if (!cand) continue;
        try {
          const tb = await fetchTablebase(cand.fen);
          if (Array.isArray(tb?.moves) && tb.moves.length > 0) return { fen: cand.fen, tb };
        } catch {}
      }

      throw new Error("Failed to generate a valid position (network/API issue?).");
    }

    async function newGame() {
      answered = false;
      currentFen = null;
      currentTb = null;
      clearArrows();

      setDetails({ fen: "—", dtz: "—", bestMovesSAN: "—" });
      setAnalyzeLink(null);

      setStatus("warn", "Generating a new position and querying the Lichess tablebase…");
      setLoading("Loading…", true);

      try {
        const { fen, tb } = await generateInterestingPosition();
        currentFen = fen;
        currentTb = tb;

        const placement = fen.split(" ")[0];
        await board.setPosition(placement);

        setAnalyzeLink(fen);

        const dtz = (typeof tb.precise_dtz === "number") ? tb.precise_dtz
                 : (typeof tb.dtz === "number") ? tb.dtz
                 : null;

        setDetails({ fen, dtz, bestMovesSAN: "—" });

        setStatus(null, "What is the theoretical result for White?\nTap Win / Draw / Loss.");
        setLoading("Ready", false);
      } catch (err) {
        setLoading("Error", false);
        setStatus("bad", String(err?.message || err));
      }
    }

    function answer(userPick) {
      if (!currentTb || answered) return;
      answered = true;
      setGuessEnabled(false);

      const correctWdl = coarseWDL(currentTb.category);
      const ok = userPick === correctWdl;

      streak = ok ? (streak + 1) : 0;
      updateStreakDisplay();

      const best = bestMovesFromTb(currentTb);
      drawBestMoveArrows(best);

      const bestSAN = best.map(m => m.san).join(", ") || "—";
      const dtz = (typeof currentTb.precise_dtz === "number") ? currentTb.precise_dtz
               : (typeof currentTb.dtz === "number") ? currentTb.dtz
               : null;

      setDetails({ fen: currentFen, dtz, bestMovesSAN: bestSAN });

      if (ok) {
        setStatus("ok", `Correct.\nOutcome: ${prettyOutcome(correctWdl)}`);
      } else {
        setStatus("bad", `Incorrect.\nCorrect outcome: ${prettyOutcome(correctWdl)}`);
      }
    }

    el.btnWin.addEventListener("click", () => answer("win"));
    el.btnDraw.addEventListener("click", () => answer("draw"));
    el.btnLoss.addEventListener("click", () => answer("loss"));
    el.btnAgain.addEventListener("click", () => newGame());

    updateStreakDisplay();
    setGuessEnabled(false);
    newGame();
  </script>
</body>
</html>
